/*
Copyright (c) 2014, Jorge Rodriguez, bs.vino@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include "viewback.h"

#include <time.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

#pragma warning(disable: 4505) /* unreferenced local function has been removed - generated because of vb_socket_is_blocking_error() not used in the Viewback server */
#pragma warning(disable: 4127) /* conditional expression is constant - generated by the uses of FD_SET */

#include "viewback_shared.h"
#include "viewback_internal.h"

#ifdef _MSC_VER
// No VLA's. Use alloca()
#include <malloc.h>
#define vb__stack_allocate(type, name, bytes) type* name = (type*)alloca(bytes)
#else
#define vb__stack_allocate(type, name, bytes) type name[bytes]
#endif

static char sprintf_buffer[1024];

void vb__sprintf(const char* format, ...)
{
	va_list ap;
	va_start(ap, format);
#ifdef _MSC_VER
	vsnprintf_s(sprintf_buffer, sizeof(sprintf_buffer), _TRUNCATE, format, ap);
#else
	vsnprintf(sprintf_buffer, sizeof(sprintf_buffer), format, ap);
#endif
	va_end(ap);
}


void vb_config_initialize(vb_config_t* config)
{
	memset(config, 0, sizeof(vb_config_t));

	config->tcp_port = VB_DEFAULT_PORT;
	config->max_connections = 4;
}

size_t vb__config_get_channel_mask_length(vb_config_t* config)
{
	if (!config)
		return 0;

	int channels = config->num_data_channels;

	if (channels <= 8)
		return 1;

	if (channels <= 16)
		return 2;

	if (channels % 32 == 0)
		// if channels == 32, we want to return 1
		return channels / 32;
	else
		// if channels == 31, we want to return 1
		// if channels == 32, we want to return 2
		return channels / 32 + 1;
}

size_t vb_config_get_memory_required(vb_config_t* config)
{
	if (!config)
		return 0;

	if (config->num_data_labels < 0)
		return 0;

	return
		sizeof(vb__t) +
		config->num_data_channels * sizeof(vb__data_channel_t)+
		config->num_data_groups * sizeof(vb__data_group_t)+
		config->num_data_group_members * sizeof(vb__data_group_member_t)+
		config->num_data_labels * sizeof(vb__data_label_t)+
		config->num_data_controls * sizeof(vb__data_control_t)+
		config->max_connections * sizeof(vb__connection_t)+
		config->max_connections * vb__config_get_channel_mask_length(config);
}

static vb__t* VB;

vb_bool vb_config_install(vb_config_t* config, void* memory, size_t memory_size)
{
	if (!config)
		return 0;

	if (!memory)
		return 0;

	/* Indicates there was a problem in vb_config_get_memory_required() which didn't get caught. */
	if (memory_size == 0)
		return 0;

	if (memory_size < vb_config_get_memory_required(config))
		return 0;

	if (VB && VB->server_active)
		return 0;

	memset(memory, 0, memory_size);

	VB = (vb__t*)memory;

	VB->config = *config;

	VB->channels = (vb__data_channel_t*)((char*)memory + sizeof(vb__t));
	VB->groups = (vb__data_group_t*)((char*)VB->channels + sizeof(vb__data_channel_t)*config->num_data_channels);
	VB->group_members = (vb__data_group_member_t*)((char*)VB->groups + sizeof(vb__data_group_t)*config->num_data_groups);
	VB->labels = (vb__data_label_t*)((char*)VB->group_members + sizeof(vb__data_group_member_t)*config->num_data_group_members);
	VB->controls = (vb__data_control_t*)((char*)VB->labels + sizeof(vb__data_label_t)*config->num_data_labels);
	VB->connections = (vb__connection_t*)((char*)VB->controls + sizeof(vb__data_control_t)*config->num_data_controls);
	char* active_channels = (char*)VB->connections + sizeof(vb__connection_t)*config->max_connections;

#ifdef _DEBUG
	char* memory_end = active_channels + vb__config_get_channel_mask_length(config)*config->max_connections;
	VBAssert(memory_end == (char*)memory + memory_size);
	memory_end = memory_end; // Quiet unused warning.
#endif

	for (size_t i = 0; i < config->max_connections; i++)
	{
		VB->connections[i].socket = VB_INVALID_SOCKET;
		VB->connections[i].active_channels = (vb__data_channel_mask_t*)(active_channels + i * vb__config_get_channel_mask_length(config));
	}

	VB->server_active = 0;

	if (!VB->config.tcp_port)
		VB->config.tcp_port = VB_DEFAULT_PORT;

	return 1;
}

void vb_config_release()
{
	VBAssert(!vb_server_is_active());

	VB = NULL;
}

vb_bool vb__data_is_channel_active(vb_channel_handle_t channel, size_t connection)
{
	if (!VB)
		return 0;

	if (!VB->server_active)
		return 0;

	if (channel == VB_CHANNEL_NONE)
		return 1;

	if (channel < 0)
		return 0;

	if (channel >= VB->next_channel)
		return 0;

	if (connection < 0)
		return 0;

	if (connection >= VB->config.max_connections)
		return 0;

	if (VB->connections[connection].socket == VB_INVALID_SOCKET)
		return 0;

	char* mask = (char*)VB->connections[connection].active_channels;

	while (channel > 8)
	{
		channel -= 8;
		mask += 1;
	}

	return !!((*mask) & (1<<channel));
}

void vb__data_channel_activate(vb_channel_handle_t channel, size_t connection)
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	if (channel < 0)
		return;

	if (channel >= VB->next_channel)
		return;

	if (connection < 0)
		return;

	if (connection >= VB->config.max_connections)
		return;

	if (VB->connections[connection].socket == VB_INVALID_SOCKET)
		return;

	char* mask = (char*)VB->connections[connection].active_channels;

	while (channel > 8)
	{
		channel -= 8;
		mask += 1;
	}

	(*mask) |= (1 << channel);
}

void vb__data_channel_deactivate(vb_channel_handle_t channel, size_t connection)
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	if (channel < 0)
		return;

	if (channel >= VB->next_channel)
		return;

	if (connection < 0)
		return;

	if (connection >= VB->config.max_connections)
		return;

	if (VB->connections[connection].socket == VB_INVALID_SOCKET)
		return;

	char* mask = (char*)VB->connections[connection].active_channels;

	while (channel > 8)
	{
		channel -= 8;
		mask += 1;
	}

	(*mask) &= ~(1 << channel);
}

vb_bool vb_data_add_channel(const char* name, vb_data_type_t type, /*out*/ vb_channel_handle_t* handle)
{
	if (!VB)
		return 0;

	if (!name)
		return 0;

	if (!name[0])
		return 0;

	if (VB->next_channel >= VB->config.num_data_channels)
		return 0;

	if (VB->server_active)
		return 0;

	if (handle)
		*handle = (vb_channel_handle_t)VB->next_channel;

	VB->channels[VB->next_channel].name = name;
	VB->channels[VB->next_channel].type = type;

	VB->next_channel++;

	return 1;
}

vb_bool vb_data_add_group(const char* name, /*out*/ vb_group_handle_t* handle)
{
	if (!VB)
		return 0;

	if (!name)
		return 0;

	if (!name[0])
		return 0;

	if (VB->next_group >= VB->config.num_data_groups)
		return 0;

	if (VB->server_active)
		return 0;

	if (handle)
		*handle = (vb_group_handle_t)VB->next_group;

	VB->groups[VB->next_group].name = name;

	VB->next_group++;

	return 1;
}

vb_bool vb_data_add_channel_to_group(vb_group_handle_t group, vb_channel_handle_t channel)
{
	if (!VB)
		return 0;

	if (channel < 0 || channel >= VB->next_channel)
		return 0;

	if (group < 0 || group >= VB->next_group)
		return 0;

	if (VB->next_group_member >= VB->config.num_data_group_members)
		return 0;

	if (VB->server_active)
		return 0;

	VB->group_members[VB->next_group_member].group = group;
	VB->group_members[VB->next_group_member].channel = channel;

	VB->next_group_member++;

	return 1;
}

vb_bool vb_data_add_label(vb_channel_handle_t handle, int value, const char* label)
{
	if (!VB)
		return 0;

	if (!label)
		return 0;

	if (!label[0])
		return 0;

	if (handle < 0 || handle >= VB->next_channel)
		return 0;

	if (VB->next_label >= VB->config.num_data_labels)
		return 0;

	if (VB->server_active)
		return 0;

	VB->labels[VB->next_label].handle = handle;
	VB->labels[VB->next_label].name = label;
	VB->labels[VB->next_label].value = value;

	VB->next_label++;

	return 1;
}

vb_bool vb_data_get_label(vb_channel_handle_t handle, int value, const char** label)
{
	if (!VB)
		return 0;

	if (handle < 0 || handle >= VB->next_channel)
		return 0;

	if (!VB->server_active)
		return 0;

	for (size_t i = 0; i < VB->next_label; i++)
	{
		if (VB->labels[i].handle == handle && VB->labels[i].value == value)
		{
			*label = VB->labels[i].name;
			return 1;
		}
	}

	return 0;
}

#ifndef VB_NO_RANGE
vb_bool vb_data_set_range(vb_channel_handle_t handle, float range_min, float range_max)
{
	if (!VB)
		return 0;

	if (handle < 0 || handle >= VB->next_channel)
		return 0;

	if (VB->server_active)
		return 0;

	VB->channels[handle].range_min = range_min;
	VB->channels[handle].range_max = range_max;

	return 1;
}
#endif

vb__data_control_t* vb__data_add_control(const char* name, vb_control_t type)
{
	if (!VB)
		return NULL;

	if (!name)
		return NULL;

	if (!name[0])
		return NULL;

	if (VB->next_control >= VB->config.num_data_controls)
		return NULL;

	if (VB->server_active)
		return NULL;

	vb__data_control_t* control = &VB->controls[VB->next_control];
	VB->next_control++;

	control->name = name;
	control->type = type;

	return control;
}


vb_bool vb_data_add_control_button(const char* name, vb_control_button_callback callback)
{
	if (!callback)
		return 0;

	vb__data_control_t* control = vb__data_add_control(name, VB_CONTROL_BUTTON);

	if (!control)
		return 0;

	control->button_callback = callback;

	return 1;
}

vb_bool vb_data_add_control_slider_float(const char* name, float range_min, float range_max, int steps, vb_control_slider_float_callback callback)
{
	if (!callback)
		return 0;

	if (steps < 0)
		return 0;

	if (range_max <= range_min)
		return 0;

	vb__data_control_t* control = vb__data_add_control(name, VB_CONTROL_SLIDER_FLOAT);

	if (!control)
		return 0;

	control->slider_float_callback = callback;
	control->slider_float.range_min = range_min;
	control->slider_float.range_max = range_max;
	control->slider_float.steps = steps;

	VB->next_control++;

	return 1;
}

vb_bool vb_data_add_control_slider_int(const char* name, int range_min, int range_max, int step_size, vb_control_slider_int_callback callback)
{
	if (!callback)
		return 0;

	if (step_size < 1)
		return 0;

	if (range_max <= range_min)
		return 0;

	vb__data_control_t* control = vb__data_add_control(name, VB_CONTROL_SLIDER_INT);

	if (!control)
		return 0;

	control->slider_int_callback = callback;
	control->slider_int.range_min = range_min;
	control->slider_int.range_max = range_max;
	control->slider_int.step_size = step_size;

	return 1;
}

vb_bool vb_data_add_control_button_command(const char* name, const char* command)
{
	if (!command)
		return 0;

	if (!command[0])
		return 0;

	vb__data_control_t* control = vb__data_add_control(name, VB_CONTROL_BUTTON);

	control->command = command;

	return 1;
}

vb_bool vb_data_add_control_slider_float_command(const char* name, float range_min, float range_max, int steps, const char* command)
{
	if (!command)
		return 0;

	if (!command[0])
		return 0;

	if (steps < 0)
		return 0;

	if (range_max <= range_min)
		return 0;

	vb__data_control_t* control = vb__data_add_control(name, VB_CONTROL_SLIDER_FLOAT);

	if (!control)
		return 0;

	control->command = command;
	control->slider_float.range_min = range_min;
	control->slider_float.range_max = range_max;
	control->slider_float.steps = steps;

	return 1;
}

vb_bool vb_data_add_control_slider_int_command(const char* name, int range_min, int range_max, int step_size, const char* command)
{
	if (!command)
		return 0;

	if (!command[0])
		return 0;

	if (step_size < 1)
		return 0;

	if (range_max <= range_min)
		return 0;

	vb__data_control_t* control = vb__data_add_control(name, VB_CONTROL_SLIDER_INT);

	if (!control)
		return 0;

	control->command = command;
	control->slider_int.range_min = range_min;
	control->slider_int.range_max = range_max;
	control->slider_int.step_size = step_size;

	return 1;
}

size_t vb__write_length_prepended_message(struct vb__Packet *_Packet, void *_buffer, size_t length, size_t(*serialize)(struct vb__Packet *_Packet, void *_buffer, size_t length));
vb_bool vb__socket_send(vb__socket_t* socket, const char* message, size_t message_length);

vb_bool vb__data_update_control(size_t i, vb_control_t control_type, void* value, size_t skip_connection)
{
	vb__stack_allocate(struct vb__DataControl, control, sizeof(struct vb__DataControl));
	memset(control, 0, sizeof(struct vb__DataControl));

	struct vb__Packet packet;
	vb__Packet_initialize(&packet);

	packet._data_controls = control;
	packet._data_controls_repeated_len = 1;

	switch (control_type)
	{
	default:
		VBAssert(0);
		return 0;

	case VB_CONTROL_SLIDER_FLOAT:
		control->_initial_float = *(float*)value;
		break;

	case VB_CONTROL_SLIDER_INT:
		control->_initial_int = *(int*)value;
		break;
	}

	control->_name = VB->controls[i].name;
	control->_name_len = strlen(VB->controls[i].name);
	control->_type = VB->controls[i].type;

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (!message_actual_length)
		return 0;

	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (VB->connections[i].socket == VB_INVALID_SOCKET)
			continue;

		if (i == skip_connection)
			continue;

		vb__socket_send(&VB->connections[i].socket, (const char*)message, message_actual_length);
	}

	return 1;
}

vb_bool vb_data_set_control_slider_float_value(const char* name, float value)
{
	if (!VB)
		return 0;

	if (!name)
		return 0;

	if (!name[0])
		return 0;

	size_t i;
	for (i = 0; i < VB->next_control; i++)
	{
		if (strcmp(VB->controls[i].name, name) == 0)
		{
			VBAssert(VB->controls[i].type == VB_CONTROL_SLIDER_FLOAT);

			if (VB->controls[i].slider_float.initial_value == value)
				return 1;

			VB->controls[i].slider_float.initial_value = value;
			break;
		}
	}

	if (i >= VB->next_control)
		return 0;

	if (VB->server_active)
		return vb__data_update_control(i, VB->controls[i].type, &value, -1);

	return 1;
}

vb_bool vb_data_set_control_slider_int_value(const char* name, int value)
{
	if (!VB)
		return 0;

	if (!name)
		return 0;

	if (!name[0])
		return 0;

	size_t i;
	for (i = 0; i < VB->next_control; i++)
	{
		if (strcmp(VB->controls[i].name, name) == 0)
		{
			VBAssert(VB->controls[i].type == VB_CONTROL_SLIDER_INT);

			if (VB->controls[i].slider_int.initial_value == value)
				return 1;

			VB->controls[i].slider_int.initial_value = value;
			break;
		}
	}

	if (i >= VB->next_control)
		return 0;

	if (VB->server_active)
		return vb__data_update_control(i, VB->controls[i].type, &value, -1);

	return 1;
}

vb_bool vb_server_create()
{
	if (!VB)
		return 0;

	if (VB->server_active)
		return 0;

	VB->multicast_socket = socket(AF_INET, SOCK_DGRAM, 0);

	if (!vb__socket_valid(VB->multicast_socket))
		// Did you call WSAStartup() first?
		return 0;

	int ttl = 10;
	if (setsockopt(VB->multicast_socket, IPPROTO_IP, IP_TTL, (const char*)&ttl, sizeof(ttl)) != 0)
	{
		VBPrintf("Couldn't set multicast socket TTL. Error: %d\n", vb__socket_error());
		goto error;
	}

	memset(&VB->multicast_addr, 0, sizeof(VB->multicast_addr));
	VB->multicast_addr.sin_family = AF_INET;
	inet_pton(AF_INET, VB_DEFAULT_MULTICAST_ADDRESS, &VB->multicast_addr.sin_addr);
	VB->multicast_addr.sin_port = htons(VB_DEFAULT_PORT);
	VB->last_multicast = 0;

	VB->tcp_socket = socket(AF_INET, SOCK_STREAM, 0);

	if (!vb__socket_valid(VB->tcp_socket))
		goto error;

#if 0
	{
		int on = 1;
		int off = 0;
		setsockopt(VB->tcp_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&on, sizeof(on));
		setsockopt(VB->tcp_socket, SOL_SOCKET, SO_LINGER, (const char*)&off, sizeof(off));
	}
#endif

#ifdef __APPLE__
	/* Don't generate SIGPIPE when writing to dead socket, we check all writes. */
	signal(SIGPIPE, SIG_IGN);
#endif

	if (vb__socket_set_blocking(VB->tcp_socket, 0) != 0)
		goto error;

	struct sockaddr_in tcp_addr;
	memset(&tcp_addr, 0, sizeof(tcp_addr));
	tcp_addr.sin_family = AF_INET;
	tcp_addr.sin_addr.s_addr = INADDR_ANY;
	tcp_addr.sin_port = htons(VB->config.tcp_port);

	int i;
	for (i = 0; i < 5; i++)
	{
		if (bind(VB->tcp_socket, (struct sockaddr*) &tcp_addr, sizeof tcp_addr) == 0)
			break;

		VB->config.tcp_port += 1;
		tcp_addr.sin_port = htons(VB->config.tcp_port);
	}

	if (i == 5)
		goto error;

	if (listen(VB->tcp_socket, SOMAXCONN) != 0)
		goto error;

	VBPrintf("Viewback server created on %s:%d (%u).\n", inet_ntoa(tcp_addr.sin_addr), ntohs(tcp_addr.sin_port), tcp_addr.sin_addr.s_addr);
	VBPrintf("Multicasting to %s:%d.\n", inet_ntoa(VB->multicast_addr.sin_addr), ntohs(VB->multicast_addr.sin_port));

	VB->server_active = 1;

	return 1;

error:
	vb__socket_close(VB->tcp_socket);
	vb__socket_close(VB->multicast_socket);
	return 0;
}

void vb_server_shutdown()
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	vb__socket_close(VB->tcp_socket);
	vb__socket_close(VB->multicast_socket);

	for (size_t i = 0; i < VB->config.max_connections; i++)
		vb__socket_close(VB->connections[i].socket);

	VB->server_active = 0;
}

vb_bool vb_server_is_active()
{
	if (!VB)
		return 0;

	if (!VB->server_active)
		return 0;

	return 1;
}

size_t vb__write_length_prepended_message(struct vb__Packet *_Packet, void *_buffer, size_t length, size_t(*serialize)(struct vb__Packet *_Packet, void *_buffer, size_t length))
{
	size_t serialized_length = (*serialize)(_Packet, (void*)((size_t)_buffer + sizeof(size_t)), length);

	/* Packet_alloca() automatically adds sizeof(size_t) bytes to the length of the packet requested, specifically to make room for this. */
	size_t network_length = htonl(serialized_length);
	memcpy(_buffer, &network_length, sizeof(network_length));

	return serialized_length + sizeof(network_length);
}

vb_bool vb__socket_send(vb__socket_t* socket, const char* message, size_t message_length)
{
	vb__socket_set_blocking(*socket, 1);

	int bytes_sent = send(*socket, message, message_length, 0);
	int socket_error = vb__socket_error();

	vb__socket_set_blocking(*socket, 0);

	if (bytes_sent == 0)
	{
		VBPrintf("Error sending to %d, disconnected.\n", *socket);
		vb__socket_close(*socket);
		*socket = VB_INVALID_SOCKET;
		return 0;
	}

	if (bytes_sent < 0)
	{
		// Should be a blocking socket.
		VBAssert(!vb__socket_is_blocking_error(socket_error));

		VBPrintf("Error (code: %d) sending to %d, disconnected.\n", socket_error, *socket);
		vb__socket_close(*socket);
		*socket = VB_INVALID_SOCKET;
		return 0;
	}

	return 1;
}

void vb__connection_setup(vb__connection_t* connection)
{
	// Clear the channel masks so all channels are inactive by default.
	memset(connection->active_channels, 0, vb__config_get_channel_mask_length(&VB->config));
}

void vb__send_registrations(vb__connection_t* connection)
{
	VBPrintf("Sending registrations to %d.\n", connection->socket);

	struct vb__Packet packet;
	vb__stack_allocate(struct vb__DataChannel, channels, VB->next_channel * sizeof(struct vb__DataChannel));
	vb__stack_allocate(struct vb__DataGroup, groups, VB->next_group * sizeof(struct vb__DataGroup));
	vb__stack_allocate(struct vb__DataLabel, labels, VB->next_label * sizeof(struct vb__DataLabel));
	vb__stack_allocate(struct vb__DataControl, controls, VB->next_control * sizeof(struct vb__DataControl));

	/* Initialize group channel membership numbers. */
	for (size_t j = 0; j < VB->next_group; j++)
		groups[j]._channels_repeated_len = 0;

	/* Count up how many there are. */
	for (size_t j = 0; j < VB->next_group_member; j++)
		groups[VB->group_members[j].group]._channels_repeated_len++;

	/* Now that we know how many there are we can allocate the memory.
	We can't just do them in a big loop because VLA's will go out of scope if they're defined in the loop. */
	int total_length = 0;
	for (size_t j = 0; j < VB->next_group; j++)
		total_length += groups[j]._channels_repeated_len * sizeof(*groups[j]._channels);

	vb__stack_allocate(unsigned long, group_channels, total_length);

	int current_group_channel = 0;
	for (size_t j = 0; j < VB->next_group; j++)
	{
		groups[j]._channels = &group_channels[current_group_channel];
		current_group_channel += groups[j]._channels_repeated_len;
	}

	vb__Packet_initialize_registrations(&packet, channels, VB->next_channel, groups, VB->next_group, labels, VB->next_label, controls, VB->next_control);

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (message_actual_length)
		vb__socket_send(&connection->socket, (const char*)message, message_actual_length);
}

#ifdef VIEWBACK_TIME_DOUBLE
void vb_server_update(double current_game_time)
#else
void vb_server_update(vb_uint64 current_game_time)
#endif
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	// This sort of thing can happen the header is compiled with VIEWBACK_TIME_DOUBLE
	// and viewback.cpp is not
	VBAssert(current_game_time >= VB->current_time);

	// This sort of thing can happen the header is compiled with VIEWBACK_TIME_DOUBLE
	// and viewback.cpp is not.
	if (VB->current_time)
#ifdef VIEWBACK_TIME_DOUBLE
		VBAssert(current_game_time - VB->current_time < 100);
#else
		VBAssert(current_game_time - VB->current_time < 100000);
#endif

	VB->current_time = current_game_time;

	time_t current_time;
	time(&current_time);

	/* Advertise ourselves once per second. */
	if (current_time > VB->last_multicast)
	{
		const char* server_name = VB->config.server_name;
		if (!server_name || server_name[0] == '\0')
			server_name = "Viewback Server";

		// 2 for "VB" + 1 for version byte + 2 for port number = 5
		int header_length = 5;
		int message_length = header_length + strlen(server_name) + 1; // 1 for null terminal
		vb__stack_allocate(char, message, message_length);
		message[0] = 'V';
		message[1] = 'B';
		message[2] = 1; // Version byte. If the format changes, we bump this so the client can parse it properly.

		unsigned short tcp_port = htons(VB->config.tcp_port);
		*((unsigned short*)&message[3]) = tcp_port;

		message[header_length] = '\0';
		vb__strcat(message + header_length, message_length - header_length, server_name);

		if (sendto(VB->multicast_socket, (const char*)message, message_length, 0, (struct sockaddr *)&VB->multicast_addr, sizeof(VB->multicast_addr)) < 0)
			VBPrintf("Multicast sendto failed, error %d\n", vb__socket_error());

		VB->last_multicast = current_time;
	}

	fd_set read_fds;

	FD_ZERO(&read_fds);

	size_t current_connections = 0;
	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (VB->connections[i].socket != VB_INVALID_SOCKET)
			current_connections++;
	}

	vb__socket_t max_socket = 0;

	if (current_connections < VB->config.max_connections)
	{
		FD_SET(VB->tcp_socket, &read_fds);
		max_socket = VB->tcp_socket;
	}

	for (size_t i = 0; i < VB->config.max_connections; ++i)
	{
		vb__socket_t socket = VB->connections[i].socket;
		if (VB->connections[i].socket == VB_INVALID_SOCKET)
			continue;

		FD_SET(socket, &read_fds);

		if (socket > max_socket)
			max_socket = socket;
	}

	struct timeval timeout;
	timeout.tv_sec = 0;
	timeout.tv_usec = 5;

	select((int) (max_socket + 1), &read_fds, NULL, NULL, &timeout);

	if (FD_ISSET(VB->tcp_socket, &read_fds))
	{
		/* We have an incoming connection. */

		VBPrintf("Incoming connection... ");

		char VB_ALIGN(8) client_addr[64];
		vb__socklen_t client_addr_len = sizeof(client_addr);
		vb__socket_t incoming_socket = accept(VB->tcp_socket, (struct sockaddr*) &client_addr[0], &client_addr_len);

		if (vb__socket_valid(incoming_socket))
		{
			vb_bool socket_success = 0;

			int open_socket = -1;
			for (size_t i = 0; i < VB->config.max_connections; i++)
			{
				if (VB->connections[i].socket == VB_INVALID_SOCKET)
				{
					open_socket = i;
					break;
				}
			}

			VBAssert(open_socket >= 0);

			if (open_socket >= 0)
			{
				VB->connections[open_socket].socket = incoming_socket;

				if (vb__socket_set_blocking(incoming_socket, 0) == 0)
				{
					vb__connection_setup(&VB->connections[open_socket]);

					socket_success = 1;
				}
			}

			if (socket_success)
			{
				VBPrintf("Successful. Socket: %d\n", incoming_socket);
				vb__send_registrations(&VB->connections[open_socket]);
			}
			else
			{
				VBPrintf("Not enough connections, increase max_connections\n");
				vb__socket_close(incoming_socket);
			}
		}
		else
			VBPrintf("Dropped.\n");
	}

	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (!vb__socket_valid(VB->connections[i].socket))
			continue;

		if (FD_ISSET(VB->connections[i].socket, &read_fds))
		{
			char mesg[1024];

			int n = recv(VB->connections[i].socket, mesg, sizeof(mesg), 0);

			if (n == 0)
			{
				vb__socket_close(VB->connections[i].socket);
				VB->connections[i].socket = VB_INVALID_SOCKET;
				continue;
			}
			else if (n == sizeof(mesg))
			{
				/* We read the whole damn thing? Shouldn't ever happen, but ignore. */
				VBAssert(0);
				continue;
			}

			if (strcmp(mesg, "registrations") == 0)
			{
				vb__send_registrations(&VB->connections[i]);
			}
			else if (strncmp(mesg, "console: ", 9) == 0)
			{
				if (VB->config.command_callback)
					(*VB->config.command_callback)(&mesg[9]);
			}
			else if (strncmp(mesg, "activate: ", 10) == 0)
			{
				int channel = atoi(mesg + 10);
				vb__data_channel_activate((vb_channel_handle_t)channel, i);
			}
			else if (strncmp(mesg, "deactivate: ", 12) == 0)
			{
				int channel = atoi(mesg + 12);
				vb__data_channel_deactivate((vb_channel_handle_t)channel, i);
			}
			else if (strncmp(mesg, "group: ", 7) == 0)
			{
				int group = atoi(mesg + 7);

				for (size_t j = 0; j < VB->next_channel; j++)
					vb__data_channel_deactivate((vb_channel_handle_t)j, i);

				for (size_t j = 0; j < VB->next_group_member; j++)
				{
					if (VB->group_members[j].group != group)
						continue;

					vb__data_channel_activate(VB->group_members[j].channel, i);

#ifndef VB_NO_COMPRESSION
					vb__data_channel_t* channel = &VB->channels[VB->group_members[j].channel];

					if (channel->flags & CHANNEL_FLAG_INITIALIZED)
					{
						if (channel->type == VB_DATATYPE_INT)
							vb_data_send_int(VB->group_members[j].channel, channel->last_int);
						else if (channel->type == VB_DATATYPE_FLOAT)
							vb_data_send_float(VB->group_members[j].channel, channel->last_float);
						else if (channel->type == VB_DATATYPE_VECTOR)
							vb_data_send_vector(VB->group_members[j].channel, channel->last_float_x, channel->last_float_y, channel->last_float_z);
						else
							VBAssert(!"Unknown channel type");
					}
#endif
				}
			}
			else if (strncmp(mesg, "control: ", 9) == 0)
			{
				size_t message_length = strlen(mesg);

				// Find out what's after the control index.
				size_t after_control_index = 9;
				while (after_control_index < message_length && mesg[after_control_index] != ' ')
					after_control_index++;

				int control = atoi(mesg + 9);

				if (control < 0 || control >= (int)VB->next_control)
					continue;

				switch (VB->controls[control].type)
				{
				case VB_CONTROL_BUTTON:
					if (VB->controls[control].button_callback)
						VB->controls[control].button_callback();
					else if (VB->controls[control].command)
						VB->config.command_callback(VB->controls[control].command);
					break;

				case VB_CONTROL_SLIDER_FLOAT:
					VBAssert(after_control_index < message_length);
					if (after_control_index < message_length)
					{
						float new_value = (float)atof(&mesg[after_control_index]);
						VB->controls[control].slider_float.initial_value = new_value;
						vb__data_update_control(control, VB_CONTROL_SLIDER_FLOAT, &new_value, i);

						if (VB->controls[control].slider_float_callback)
							VB->controls[control].slider_float_callback(new_value);
						else if (VB->controls[control].command)
						{
							if (strstr(VB->controls[control].command, "%f"))
								vb__sprintf(VB->controls[control].command, (float)new_value);
							else
								vb__sprintf("%s %f", VB->controls[control].command, (float)new_value);

							VB->config.command_callback(sprintf_buffer);
						}
					}
					break;

				case VB_CONTROL_SLIDER_INT:
					VBAssert(after_control_index < message_length);
					if (after_control_index < message_length)
					{
						int new_value = atoi(&mesg[after_control_index]);
						VB->controls[control].slider_int.initial_value = new_value;
						vb__data_update_control(control, VB_CONTROL_SLIDER_INT, &new_value, i);

						if (VB->controls[control].slider_int_callback)
							VB->controls[control].slider_int_callback(new_value);
						else if (VB->controls[control].command)
						{
							if (strstr(VB->controls[control].command, "%f"))
								vb__sprintf(VB->controls[control].command, (float)new_value);
							else
								vb__sprintf("%s %f", VB->controls[control].command, (float)new_value);

							VB->config.command_callback(sprintf_buffer);
						}
					}
					break;
				}
			}
		}
	}
}

void vb__send_to_all(vb_channel_handle_t channel, void* message, size_t message_length)
{
	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (VB->connections[i].socket == VB_INVALID_SOCKET)
			continue;

		if (!vb__data_is_channel_active(channel, i))
			continue;

		vb__socket_send(&VB->connections[i].socket, (const char*)message, message_length);
	}
}

/*

Maintain time trick:

Data:     A A C B B B C D D A
Tossed:     x     x x     x
Maintain:   m->   m-m->   m->

The data comes in A B C or D. If this value is equal to the previous value,
this data gets tossed (marked by the x above.) Then the "maintain time"
is set (marked by the m above) indicating that the client should maintain
the previous value. Once a new value is received by the server, it is sent
to the client along with the maintain time, indicated by >.

*/

vb_bool vb_data_send_int(vb_channel_handle_t handle, int value)
{
	if (!VB)
		return 0;

	if (handle < 0)
		return 0;

	if (handle >= VB->next_channel)
		return 0;

	vb__data_channel_t* channel = &VB->channels[handle];

	if (channel->type != VB_DATATYPE_INT)
		return 0;

	if (!VB->server_active)
		return 0;

#ifndef VB_NO_COMPRESSION
	if (channel->flags & CHANNEL_FLAG_INITIALIZED)
	{
		if (value == channel->last_int)
		{
			channel->maintain_time = VB->current_time;
			return 1;
		}
	}
	else
		channel->flags |= CHANNEL_FLAG_INITIALIZED;

	channel->last_int = value;
#endif

	struct vb__Packet packet;
	struct vb__Data data;
	vb__Packet_initialize_data(&packet, &data, VB_DATATYPE_INT);

	data._handle = handle;
	data._data_int = value;

#ifndef VB_NO_COMPRESSION
#ifdef VIEWBACK_TIME_DOUBLE
	data._maintain_time_double = channel->maintain_time;
#else
	data._maintain_time_uint64 = channel->maintain_time;
#endif
#endif

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb__send_to_all(handle, message, message_actual_length);

#ifndef VB_NO_COMPRESSION
	channel->maintain_time = 0;
#endif

	return 1;
}

vb_bool vb_data_send_float(vb_channel_handle_t handle, float value)
{
	if (!VB)
		return 0;

	if (handle < 0)
		return 0;

	if (handle >= VB->next_channel)
		return 0;

	vb__data_channel_t* channel = &VB->channels[handle];

	if (channel->type != VB_DATATYPE_FLOAT)
		return 0;

	if (!VB->server_active)
		return 0;

#ifndef VB_NO_COMPRESSION
	if (channel->flags & CHANNEL_FLAG_INITIALIZED)
	{
		// I'm okay with using float == here
		if (value == channel->last_float)
		{
			channel->maintain_time = VB->current_time;
			return 1;
		}
	}
	else
		channel->flags |= CHANNEL_FLAG_INITIALIZED;

	channel->last_float = value;
#endif

	struct vb__Packet packet;
	struct vb__Data data;
	vb__Packet_initialize_data(&packet, &data, VB_DATATYPE_FLOAT);

	data._handle = handle;
	data._data_float = value;

#ifndef VB_NO_COMPRESSION
#ifdef VIEWBACK_TIME_DOUBLE
	data._maintain_time_double = channel->maintain_time;
#else
	data._maintain_time_uint64 = channel->maintain_time;
#endif
#endif

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb__send_to_all(handle, message, message_actual_length);

#ifndef VB_NO_COMPRESSION
	channel->maintain_time = 0;
#endif

	return 1;
}

vb_bool vb_data_send_vector(vb_channel_handle_t handle, float x, float y, float z)
{
	if (!VB)
		return 0;

	if (handle < 0)
		return 0;

	if (handle >= VB->next_channel)
		return 0;

	vb__data_channel_t* channel = &VB->channels[handle];

	if (channel->type != VB_DATATYPE_VECTOR)
		return 0;

	if (!VB->server_active)
		return 0;

#ifndef VB_NO_COMPRESSION
	if (channel->flags & CHANNEL_FLAG_INITIALIZED)
	{
		// I'm okay with using float == here
		if (x == channel->last_float_x && y == channel->last_float_y && z == channel->last_float_z)
		{
			channel->maintain_time = VB->current_time;
			return 1;
		}
	}
	else
		channel->flags |= CHANNEL_FLAG_INITIALIZED;

	channel->last_float_x = x;
	channel->last_float_y = y;
	channel->last_float_z = z;
#endif

	struct vb__Packet packet;
	struct vb__Data data;
	vb__Packet_initialize_data(&packet, &data, VB_DATATYPE_VECTOR);

	data._handle = handle;
	data._data_float_x = x;
	data._data_float_y = y;
	data._data_float_z = z;

#ifndef VB_NO_COMPRESSION
#ifdef VIEWBACK_TIME_DOUBLE
	data._maintain_time_double = channel->maintain_time;
#else
	data._maintain_time_uint64 = channel->maintain_time;
#endif
#endif

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb__send_to_all(handle, message, message_actual_length);

#ifndef VB_NO_COMPRESSION
	channel->maintain_time = 0;
#endif

	return 1;
}

vb_bool vb_data_send_int_s(const char* channel, int value)
{
	if (!channel)
		return 0;

	if (!channel[0])
		return 0;

	for (size_t i = 0; i < VB->next_channel; i++)
	{
		if (strcmp(VB->channels[i].name, channel) == 0 && VB->channels[i].type == VB_DATATYPE_INT)
			return vb_data_send_int((vb_channel_handle_t)i, value);
	}

	return 0;
}

vb_bool vb_data_send_float_s(const char* channel, float value)
{
	if (!channel)
		return 0;

	if (!channel[0])
		return 0;

	for (size_t i = 0; i < VB->next_channel; i++)
	{
		if (strcmp(VB->channels[i].name, channel) == 0 && VB->channels[i].type == VB_DATATYPE_FLOAT)
			return vb_data_send_float((vb_channel_handle_t)i, value);
	}

	return 0;
}

vb_bool vb_data_send_vector_s(const char* channel, float x, float y, float z)
{
	if (!channel)
		return 0;

	if (!channel[0])
		return 0;

	for (size_t i = 0; i < VB->next_channel; i++)
	{
		if (strcmp(VB->channels[i].name, channel) == 0 && VB->channels[i].type == VB_DATATYPE_VECTOR)
			return vb_data_send_vector((vb_channel_handle_t)i, x, y, z);
	}

	return 0;
}

vb_bool vb_console_append(const char* text)
{
	if (!VB)
		return 0;

	if (!VB->server_active)
		return 0;

	struct vb__Packet packet;
	vb__Packet_initialize(&packet);

	packet._console_output = text;
	packet._console_output_len = strlen(text);

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb__send_to_all(VB_CHANNEL_NONE, message, message_actual_length);

	return 1;
}

vb_bool vb_status_set(const char* text)
{
	if (!VB)
		return 0;

	if (!VB->server_active)
		return 0;

	struct vb__Packet packet;
	vb__Packet_initialize(&packet);

	packet._status = text;
	packet._status_len = strlen(text);

	size_t message_predicted_length = vb__Packet_get_message_size(&packet);
	Packet_alloca(message, message_predicted_length);

	size_t message_actual_length = vb__write_length_prepended_message(&packet, message, message_predicted_length, &vb__Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb__send_to_all(VB_CHANNEL_NONE, message, message_actual_length);

	return 1;
}

void vb__debug_printf(const char* format, ...)
{
	if (!VB->config.debug_output_callback)
		return;

	char buf[1024];
	va_list ap;
	va_start(ap, format);
#ifdef _MSC_VER
	vsnprintf_s(buf, sizeof(buf), _TRUNCATE, format, ap);
#else
	vsnprintf(buf, sizeof(buf), format, ap);
#endif
	va_end(ap);

	VB->config.debug_output_callback(buf);
}











/* ====================================== PROTOBUF GENERATOR ====================================== */
/* This code unscrupulously stolen from http://code.google.com/p/protobuf-embedded-c/ 
which is under the http://www.apache.org/licenses/LICENSE-2.0 Apache license.
In accordance with this license I must inform you that I have modified it for my purposes. */

int vb__write_raw_byte(char value, void *_buffer, int offset)
{
	*((char *)_buffer + offset) = value;
	return ++offset;
}

int vb__write_raw_bytes(const char *bytes, int bytes_size, void *_buffer, int offset)
{
	int i; 
	for (i = 0; i < bytes_size; ++ i)
	{
		offset = vb__write_raw_byte((char)*(bytes + i), _buffer, offset);
	}

	return offset;
}

int vb__write_raw_varint32(unsigned long value, void *_buffer, int offset)
{
	while (1)
	{
		if ((value & ~0x7F) == 0)
		{
			offset = vb__write_raw_byte((char)value, _buffer, offset);
			return offset;
		}
		else
		{
			offset = vb__write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
			value = value >> 7;
		}
	}
	return offset;
}

int vb__write_raw_varint64(unsigned long long value, void *_buffer, int offset)
{
	while (1)
	{
		if ((value & ~0x7F) == 0)
		{
			offset = vb__write_raw_byte((char)value, _buffer, offset);
			return offset;
		}
		else
		{
			offset = vb__write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
			value = value >> 7;
		}
	}
	return offset;
}

#define PB_WIRE_TYPE_VARINT           0
#define PB_WIRE_TYPE_64BIT            1
#define PB_WIRE_TYPE_LENGTH_DELIMITED 2
#define PB_WIRE_TYPE_32BIT            5

int vb__write_wire_format(unsigned long field_number, unsigned char wire_type, void *_buffer, int offset)
{
	return vb__write_raw_varint32((field_number << 3) + wire_type, _buffer, offset);
}

int vb__write_raw_little_endian32(unsigned long value, void *_buffer, int offset)
{
	offset = vb__write_raw_byte((char)((value)& 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 8) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);

	return offset;
}

int vb__write_raw_little_endian64(unsigned long long value, void *_buffer, int offset)
{
	offset = vb__write_raw_byte((char)((value)& 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 8) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 32) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 40) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 48) & 0xFF), _buffer, offset);
	offset = vb__write_raw_byte((char)((value >> 56) & 0xFF), _buffer, offset);

	return offset;
}

int vb__data_type_t_write_with_tag(vb_data_type_t *_vb_data_type_t, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = vb__write_wire_format(tag, PB_WIRE_TYPE_VARINT, _buffer, offset);
	/* Write content.*/
	offset = vb__write_raw_varint32(*_vb_data_type_t, _buffer, offset);

	return offset;
}

int vb__Data_write(struct vb__Data *_Data, void *_buffer, int offset)
{
	/* Always write the handle */
	offset = vb__write_wire_format(1, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint32(_Data->_handle, _buffer, offset);

	if (_Data->_type == VB_DATATYPE_INT)
	{
		offset = vb__write_wire_format(3, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_Data->_data_int, _buffer, offset);
	}

	if (_Data->_type == VB_DATATYPE_FLOAT)
	{
		unsigned long *data_float_ptr = (unsigned long *)&_Data->_data_float;

		offset = vb__write_wire_format(4, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*data_float_ptr, _buffer, offset);
	}

	if (_Data->_type == VB_DATATYPE_VECTOR)
	{
		unsigned long *data_float_x_ptr = (unsigned long *)&_Data->_data_float_x;
		unsigned long *data_float_y_ptr = (unsigned long *)&_Data->_data_float_y;
		unsigned long *data_float_z_ptr = (unsigned long *)&_Data->_data_float_z;

		offset = vb__write_wire_format(5, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*data_float_x_ptr, _buffer, offset);

		offset = vb__write_wire_format(6, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*data_float_y_ptr, _buffer, offset);

		offset = vb__write_wire_format(7, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*data_float_z_ptr, _buffer, offset);
	}

#ifdef VIEWBACK_TIME_DOUBLE
	unsigned long long *data_time = (unsigned long long *)&_Data->_time_double;
	offset = vb__write_wire_format(8, PB_WIRE_TYPE_64BIT, _buffer, offset);
	offset = vb__write_raw_little_endian64(*data_time, _buffer, offset);
#else
	offset = vb__write_wire_format(9, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint64(_Data->_time_uint64, _buffer, offset);
#endif

#ifdef VIEWBACK_TIME_DOUBLE
	if (_Data->_maintain_time_double)
	{
		unsigned long long *data_maintain_time = (unsigned long long *)&_Data->_maintain_time_double;
		offset = vb__write_wire_format(10, PB_WIRE_TYPE_64BIT, _buffer, offset);
		offset = vb__write_raw_little_endian64(*data_maintain_time, _buffer, offset);
	}
#else
	if (_Data->_maintain_time_uint64)
	{
		offset = vb__write_wire_format(11, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint64(_Data->_maintain_time_uint64, _buffer, offset);
	}
#endif

	return offset;
}

int vb__Data_write_delimited_to(struct vb__Data *_Data, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = vb__Data_write(_Data, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	vb__write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int vb__Data_write_with_tag(struct vb__Data *_Data, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = vb__write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = vb__Data_write_delimited_to(_Data, _buffer, offset);

	return offset;
}

int vb__DataChannel_write(struct vb__DataChannel *_DataChannel, void *_buffer, int offset)
{
	VBAssert(_DataChannel->_field_name_len);
	VBAssert(_DataChannel->_field_name);
	VBAssert(_DataChannel->_field_name[0]);
	VBAssert(_DataChannel->_type);

	if (_DataChannel->_field_name_len != 1 || _DataChannel->_field_name[0] != '0')
	{
		offset = vb__write_wire_format(1, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = vb__write_raw_varint32(_DataChannel->_field_name_len, _buffer, offset);
		offset = vb__write_raw_bytes(_DataChannel->_field_name, _DataChannel->_field_name_len, _buffer, offset);
	}

	offset = vb__data_type_t_write_with_tag(&_DataChannel->_type, _buffer, offset, 2);

	offset = vb__write_wire_format(3, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint32(_DataChannel->_handle, _buffer, offset);

#ifndef VB_NO_RANGE
	if (_DataChannel->_min != 0 || _DataChannel->_max != 0)
	{
		unsigned long *min_ptr = (unsigned long *)&_DataChannel->_min;
		unsigned long *max_ptr = (unsigned long *)&_DataChannel->_max;

		offset = vb__write_wire_format(4, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*min_ptr, _buffer, offset);

		offset = vb__write_wire_format(5, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*max_ptr, _buffer, offset);
	}
#endif

	return offset;
}

int vb__DataGroup_write(struct vb__DataGroup *_DataGroup, void *_buffer, int offset)
{
	VBAssert(_DataGroup->_name_len);
	VBAssert(_DataGroup->_name);
	VBAssert(_DataGroup->_name[0]);

	if (_DataGroup->_name_len != 1 || _DataGroup->_name[0] != '0')
	{
		offset = vb__write_wire_format(1, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = vb__write_raw_varint32(_DataGroup->_name_len, _buffer, offset);
		offset = vb__write_raw_bytes(_DataGroup->_name, _DataGroup->_name_len, _buffer, offset);
	}

	for (int channels_cnt = 0; channels_cnt < _DataGroup->_channels_repeated_len; ++channels_cnt)
	{
		offset = vb__write_wire_format(2, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_DataGroup->_channels[channels_cnt], _buffer, offset);
	}

	return offset;
}

int vb__DataLabel_write(struct vb__DataLabel *_DataLabel, void *_buffer, int offset)
{
	VBAssert(_DataLabel->_field_name_len);
	VBAssert(_DataLabel->_field_name);
	VBAssert(_DataLabel->_field_name[0]);

	offset = vb__write_wire_format(1, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint32(_DataLabel->_handle, _buffer, offset);

	offset = vb__write_wire_format(2, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint32(_DataLabel->_value, _buffer, offset);

	if (_DataLabel->_field_name_len != 1 || _DataLabel->_field_name[0] != '0')
	{
		offset = vb__write_wire_format(3, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = vb__write_raw_varint32(_DataLabel->_field_name_len, _buffer, offset);
		offset = vb__write_raw_bytes(_DataLabel->_field_name, _DataLabel->_field_name_len, _buffer, offset);
	}

	return offset;
}

int vb__DataControl_write(struct vb__DataControl *_DataControl, void *_buffer, int offset)
{
	VBAssert(_DataControl->_name_len);
	VBAssert(_DataControl->_name);
	VBAssert(_DataControl->_name[0]);

	if (_DataControl->_name_len != 1 || _DataControl->_name[0] != '0')
	{
		offset = vb__write_wire_format(1, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = vb__write_raw_varint32(_DataControl->_name_len, _buffer, offset);
		offset = vb__write_raw_bytes(_DataControl->_name, _DataControl->_name_len, _buffer, offset);
	}

	offset = vb__write_wire_format(2, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint32(_DataControl->_type, _buffer, offset);

	if (_DataControl->_type == VB_CONTROL_SLIDER_FLOAT)
	{
		unsigned long *min_ptr = (unsigned long *)&_DataControl->_range_min_float;
		unsigned long *max_ptr = (unsigned long *)&_DataControl->_range_max_float;
		unsigned long *initial = (unsigned long *)&_DataControl->_initial_float;

		offset = vb__write_wire_format(3, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*min_ptr, _buffer, offset);

		offset = vb__write_wire_format(4, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*max_ptr, _buffer, offset);

		offset = vb__write_wire_format(5, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_DataControl->_num_steps, _buffer, offset);

		offset = vb__write_wire_format(9, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = vb__write_raw_little_endian32(*initial, _buffer, offset);
	}

	if (_DataControl->_type == VB_CONTROL_SLIDER_INT)
	{
		offset = vb__write_wire_format(6, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_DataControl->_range_min_int, _buffer, offset);

		offset = vb__write_wire_format(7, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_DataControl->_range_max_int, _buffer, offset);

		offset = vb__write_wire_format(8, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_DataControl->_step_size, _buffer, offset);

		offset = vb__write_wire_format(10, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = vb__write_raw_varint32(_DataControl->_initial_int, _buffer, offset);
	}

	return offset;
}

int vb__DataChannel_write_delimited_to(struct vb__DataChannel *_DataChannel, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = vb__DataChannel_write(_DataChannel, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	vb__write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int vb__DataGroup_write_delimited_to(struct vb__DataGroup *_DataGroup, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = vb__DataGroup_write(_DataGroup, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; --i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	vb__write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int vb__DataLabel_write_delimited_to(struct vb__DataLabel *_DataLabel, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = vb__DataLabel_write(_DataLabel, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; --i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	vb__write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int vb__DataControl_write_delimited_to(struct vb__DataControl *_DataControl, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = vb__DataControl_write(_DataControl, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; --i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	vb__write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int vb__DataChannel_write_with_tag(struct vb__DataChannel *_DataChannel, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = vb__write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = vb__DataChannel_write_delimited_to(_DataChannel, _buffer, offset);

	return offset;
}

int vb__DataGroup_write_with_tag(struct vb__DataGroup *_DataGroup, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = vb__write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = vb__DataGroup_write_delimited_to(_DataGroup, _buffer, offset);

	return offset;
}

int vb__DataLabel_write_with_tag(struct vb__DataLabel *_DataLabel, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = vb__write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = vb__DataLabel_write_delimited_to(_DataLabel, _buffer, offset);

	return offset;
}

int vb__DataControl_write_with_tag(struct vb__DataControl *_DataControl, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = vb__write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = vb__DataControl_write_delimited_to(_DataControl, _buffer, offset);

	return offset;
}

int vb__Packet_write(struct vb__Packet *_Packet, void *_buffer, int offset)
{
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if (_Packet->_data)
	{
		offset = vb__Data_write_with_tag(_Packet->_data, _buffer, offset, 1);
	}

	for (int data_channels_cnt = 0; data_channels_cnt < _Packet->_data_channels_repeated_len; ++data_channels_cnt)
		offset = vb__DataChannel_write_with_tag(&_Packet->_data_channels[data_channels_cnt], _buffer, offset, 2);

	for (int data_groups_cnt = 0; data_groups_cnt < _Packet->_data_groups_repeated_len; ++data_groups_cnt)
		offset = vb__DataGroup_write_with_tag(&_Packet->_data_groups[data_groups_cnt], _buffer, offset, 3);

	for (int data_labels_cnt = 0; data_labels_cnt < _Packet->_data_labels_repeated_len; ++data_labels_cnt)
		offset = vb__DataLabel_write_with_tag(&_Packet->_data_labels[data_labels_cnt], _buffer, offset, 4);

	for (int data_controls_cnt = 0; data_controls_cnt < _Packet->_data_controls_repeated_len; ++data_controls_cnt)
		offset = vb__DataControl_write_with_tag(&_Packet->_data_controls[data_controls_cnt], _buffer, offset, 5);

	if (_Packet->_console_output_len && _Packet->_console_output && _Packet->_console_output[0])
	{
		offset = vb__write_wire_format(6, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = vb__write_raw_varint32(_Packet->_console_output_len, _buffer, offset);
		offset = vb__write_raw_bytes(_Packet->_console_output, _Packet->_console_output_len, _buffer, offset);
	}

	if (_Packet->_status_len && _Packet->_status && _Packet->_status[0])
	{
		offset = vb__write_wire_format(7, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = vb__write_raw_varint32(_Packet->_status_len, _buffer, offset);
		offset = vb__write_raw_bytes(_Packet->_status, _Packet->_status_len, _buffer, offset);
	}

	offset = vb__write_wire_format(8, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = vb__write_raw_varint32(_Packet->_is_registration, _buffer, offset);

	return offset;
}

void vb__Packet_initialize(struct vb__Packet* packet)
{
	memset(packet, 0, sizeof(struct vb__Packet));
}

void vb__Packet_initialize_data(struct vb__Packet* packet, struct vb__Data* data, vb_data_type_t type)
{
	memset(packet, 0, sizeof(struct vb__Packet));

	packet->_is_registration = 0;
	packet->_data = data;

	memset(data, 0, sizeof(struct vb__Data));

	data->_type = type;

#ifdef VIEWBACK_TIME_DOUBLE
	data->_time_double = VB->current_time;
#else
	data->_time_uint64 = VB->current_time;
#endif
}

void vb__Packet_initialize_registrations(struct vb__Packet* packet, struct vb__DataChannel* data_channels, size_t channels, struct vb__DataGroup* data_groups, size_t groups, struct vb__DataLabel* data_labels, size_t labels, struct vb__DataControl* data_controls, size_t controls)
{
	memset(packet, 0, sizeof(struct vb__Packet));

	packet->_is_registration = 1;

	packet->_data_channels = data_channels;
	packet->_data_channels_repeated_len = channels;

	packet->_data_groups = data_groups;
	packet->_data_groups_repeated_len = groups;

	packet->_data_labels = data_labels;
	packet->_data_labels_repeated_len = labels;

	packet->_data_controls = data_controls;
	packet->_data_controls_repeated_len = controls;

	memset(data_channels, 0, sizeof(struct vb__DataChannel) * channels);
	/* memset(data_groups, 0, sizeof(struct vb__DataGroup) * groups); /* Don't zero the groups or we'll lose the channels allocation that was done. */
	memset(data_labels, 0, sizeof(struct vb__DataLabel) * labels);
	memset(data_controls, 0, sizeof(struct vb__DataControl) * controls);

	VBAssert(channels == VB->next_channel);
	for (size_t i = 0; i < channels; i++)
	{
		data_channels[i]._field_name = VB->channels[i].name;
		data_channels[i]._field_name_len = strlen(VB->channels[i].name);
		data_channels[i]._handle = i;
		data_channels[i]._type = VB->channels[i].type;
#ifndef VB_NO_RANGE
		data_channels[i]._min = VB->channels[i].range_min;
		data_channels[i]._max = VB->channels[i].range_max;
#endif
	}

	VBAssert(groups == VB->next_group);
	for (size_t i = 0; i < groups; i++)
	{
		data_groups[i]._name = VB->groups[i].name;
		data_groups[i]._name_len = strlen(VB->groups[i].name);
	}

	/* Re-initialize group channel membership numbers, we're going to use them as counters. */
	for (size_t i = 0; i < VB->next_group; i++)
		data_groups[i]._channels_repeated_len = 0;

	/* Fill in the data. */
	for (size_t i = 0; i < VB->next_group_member; i++)
	{
		vb__data_group_member_t* group_member = &VB->group_members[i];
		struct vb__DataGroup* group = &data_groups[group_member->group];
		group->_channels[group->_channels_repeated_len] = group_member->channel;
		group->_channels_repeated_len++;
	}

	VBAssert(labels == VB->next_label);
	for (size_t i = 0; i < labels; i++)
	{
		data_labels[i]._field_name = VB->labels[i].name;
		data_labels[i]._field_name_len = strlen(VB->labels[i].name);
		data_labels[i]._handle = VB->labels[i].handle;
		data_labels[i]._value = VB->labels[i].value;
	}

	VBAssert(controls == VB->next_control);
	for (size_t i = 0; i < controls; i++)
	{
		data_controls[i]._name = VB->controls[i].name;
		data_controls[i]._name_len = strlen(VB->controls[i].name);
		data_controls[i]._type = VB->controls[i].type;

		switch (VB->controls[i].type)
		{
		case VB_CONTROL_BUTTON:
			// No parameters.
			break;

		case VB_CONTROL_SLIDER_FLOAT:
			data_controls[i]._range_min_float = VB->controls[i].slider_float.range_min;
			data_controls[i]._range_max_float = VB->controls[i].slider_float.range_max;
			data_controls[i]._num_steps = VB->controls[i].slider_float.steps;
			data_controls[i]._initial_float = VB->controls[i].slider_float.initial_value;
			break;

		case VB_CONTROL_SLIDER_INT:
			data_controls[i]._range_min_int = VB->controls[i].slider_int.range_min;
			data_controls[i]._range_max_int = VB->controls[i].slider_int.range_max;
			data_controls[i]._step_size = VB->controls[i].slider_int.step_size;
			data_controls[i]._initial_int = VB->controls[i].slider_int.initial_value;
			break;

		default:
			VBUnimplemented();
			break;
		}
	}
}

size_t vb__Packet_get_message_size(struct vb__Packet *_Packet)
{
	size_t size = 0;

	if (_Packet->_data)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 1; /* One byte for the length of Data, which is going to be max 40 or so. */

		size += 1; /* One byte for "handle" and wire type. */
		size += 3; /* 3 bytes is enough for a varint-encoded unsigned short. */

		if (_Packet->_data->_type == VB_DATATYPE_INT)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a varint. */
		}

		if (_Packet->_data->_type == VB_DATATYPE_FLOAT)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */
		}

		if (_Packet->_data->_type == VB_DATATYPE_VECTOR)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */
		}

		size += 1; /* One byte for "time" field number and wire type */
		size += 8; /* 8 bytes for a double. */

#ifdef VIEWBACK_TIME_DOUBLE
		if (_Packet->_data->_maintain_time_double)
#else
		if (_Packet->_data->_maintain_time_uint64)
#endif
		{
			size += 1; /* One byte for "maintain_time" field number and wire type */
			size += 10; /* If it's a double it'll be 8 bits but if it's a 64 bit varint it could be as many as 10. */
		}
	}

	if (_Packet->_data_channels_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Channels. */

		for (int i = 0; i < _Packet->_data_channels_repeated_len; i++)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 1; /* One byte for the length of DataChannel, which is going to be max 50 or so. */

			size += 1; /* One byte for "type" field number and wire type. */
			size += 2; /* Two bytes in case we ever get a lot of types. */

			size += 1; /* One byte for "handle" field number and wire type. */
			size += 3; /* 3 bytes is enough for a varint-encoded unsigned short. */

			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			size += 1; /* One byte for "min" field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the "max" number and wire type. */
			size += 4; /* 4 bytes for a float. */

			/* Add on the size for each string. */
			size += _Packet->_data_channels[i]._field_name_len;
		}
	}

	if (_Packet->_data_groups_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Groups. */

		for (int i = 0; i < _Packet->_data_groups_repeated_len; i++)
		{
			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			/* Add on the size for each string. */
			size += _Packet->_data_groups[i]._name_len;

			int channels = _Packet->_data_groups[i]._channels_repeated_len;
			size += 1 * channels; /* One byte for "channels" field number and wire type. */
			size += 3 * channels; /* 3 bytes is enough for a varint-encoded unsigned short. */
		}
	}

	if (_Packet->_data_labels_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Labels. */

		for (int i = 0; i < _Packet->_data_labels_repeated_len; i++)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 1; /* One byte for the length of DataLabel, which is going to be max 50 or so. */

			size += 1; /* One byte for "handle" field number and wire type. */
			size += 3; /* 3 bytes is enough for a varint-encoded unsigned short. */

			size += 1; /* One byte for "value" field number and wire type. */
			size += 8; /* Value could be anything, assume 8 byte long is possible. */

			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			/* Add on the size for each string. */
			size += _Packet->_data_labels[i]._field_name_len;
		}
	}

	if (_Packet->_data_controls_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Controls. */

		for (int i = 0; i < _Packet->_data_controls_repeated_len; i++)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 1; /* One byte for the length of DataControl, which is going to be max 50 or so. */

			size += 1; /* One byte for "type" field number and wire type. */
			size += 2; /* Two bytes in case we ever get a lot of types. */

			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			// Float slider is the largest in size so we'll do it and
			// leave the rest alone, since they never appear together.
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for "num_steps" field number and wire type. */
			size += 4; /* Four bytes because you never know. */

			size += 1; // One byte for "value_float" field number and wire type
			size += 1; // One byte for "value_float" data

			size += 1; // One byte for "value_int" field number and wire type
			size += 1; // One byte for "value_int" data

			/* Add on the size for each string. */
			size += _Packet->_data_controls[i]._name_len;
		}
	}

	if (_Packet->_console_output_len)
	{
		size += 1; /* One byte for field number and wire type. */
		size += 4; /* 4 bytes to support really long strings. */
		size += _Packet->_console_output_len;
	}

	if (_Packet->_status_len)
	{
		size += 1; /* One byte for field number and wire type. */
		size += 4; /* 4 bytes to support really long strings. */
		size += _Packet->_status_len;
	}

	size += 1; // One byte for "is_registration" field number and wire type
	size += 1; // One byte for "is_registration" data

	return size;
}

size_t vb__Packet_serialize(struct vb__Packet *_Packet, void *_buffer, size_t length)
{
	size_t end_offset = vb__Packet_write(_Packet, _buffer, 0);

	VBAssert(end_offset < length);

	/* Uh-oh, some overwriting happened. Too late to fix it, but don't use it. */
	if (end_offset >= length)
		return 0;

	return end_offset;
}
