/*
Copyright (c) 2014, Jorge Rodriguez, bs.vino@gmail.com

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software must display the following acknowledgement:
   This product includes software developed by Jorge Rodriguez.
4. Neither the name of the Jorge Rodriguez nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY JORGE RODRIGUEZ ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JORGE RODRIGUEZ BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "viewback.h"

#include <malloc.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#ifdef __linux__
#include <alloca.h>
#endif

#pragma warning(disable: 4505) /* unreferenced local function has been removed - generated because of vb_socket_is_blocking_error() not used in the Viewback server */
#pragma warning(disable: 4127) /* conditional expression is constant - generated by the uses of FD_SET */

#include "viewback_shared.h"
#include "viewback_internal.h"

void vb_config_initialize(vb_config_t* config)
{
	memset(config, 0, sizeof(vb_config_t));

	config->multicast_group = VB_DEFAULT_MULTICAST_ADDRESS;
	config->port = VB_DEFAULT_PORT;
	config->max_connections = 4;
}

size_t vb_config_get_channel_mask_length(vb_config_t* config)
{
	if (!config)
		return 0;

	int channels = config->num_data_channels;

	if (channels <= 8)
		return 1;

	if (channels <= 16)
		return 2;

	if (channels % 32 == 0)
		// if channels == 32, we want to return 1
		return channels / 32;
	else
		// if channels == 31, we want to return 1
		// if channels == 32, we want to return 2
		return channels / 32 + 1;
}

size_t vb_config_get_memory_required(vb_config_t* config)
{
	if (!config)
		return 0;

	if (config->num_data_channels <= 0)
		return 0;

	if (config->num_data_labels < 0)
		return 0;

	return
		sizeof(vb_t) +
		config->num_data_channels * sizeof(vb_data_channel_t)+
		config->num_data_groups * sizeof(vb_data_group_t)+
		config->num_data_group_members * sizeof(vb_data_group_member_t)+
		config->num_data_labels * sizeof(vb_data_label_t)+
		config->max_connections * sizeof(vb_connection_t)+
		config->max_connections * vb_config_get_channel_mask_length(config);
}

static vb_t* VB;

int vb_config_install(vb_config_t* config, void* memory, size_t memory_size)
{
	if (!config)
		return 0;

	if (!memory)
		return 0;

	/* Indicates there was a problem in vb_config_get_memory_required() which didn't get caught. */
	if (memory_size == 0)
		return 0;

	if (memory_size < vb_config_get_memory_required(config))
		return 0;

	if (VB && VB->server_active)
		return 0;

	memset(memory, 0, memory_size);

	VB = (vb_t*)memory;

	VB->config = *config;

	VB->channels = (vb_data_channel_t*)((char*)memory + sizeof(vb_t));
	VB->groups = (vb_data_group_t*)((char*)VB->channels + sizeof(vb_data_channel_t)*config->num_data_channels);
	VB->group_members = (vb_data_group_member_t*)((char*)VB->groups + sizeof(vb_data_group_t)*config->num_data_groups);
	VB->labels = (vb_data_label_t*)((char*)VB->group_members + sizeof(vb_data_group_member_t)*config->num_data_group_members);
	VB->connections = (vb_connection_t*)((char*)VB->labels + sizeof(vb_data_label_t)*config->num_data_labels);
	char* active_channels = (char*)VB->connections + sizeof(vb_connection_t)*config->max_connections;

	char* memory_end = active_channels + vb_config_get_channel_mask_length(config)*config->max_connections;
	VBAssert(memory_end == (char*)memory + memory_size);

	for (size_t i = 0; i < config->max_connections; i++)
	{
		VB->connections[i].socket = VB_INVALID_SOCKET;
		VB->connections[i].active_channels = (vb_data_channel_mask_t*)(active_channels + i * vb_config_get_channel_mask_length(config));
	}

	VB->server_active = false;

	return 1;
}

bool vb_data_is_channel_active(vb_channel_handle_t channel, size_t connection)
{
	if (!VB)
		return false;

	if (!VB->server_active)
		return false;

	if (channel == VB_CHANNEL_NONE)
		return true;

	if (channel < 0)
		return false;

	if (channel >= VB->next_channel)
		return false;

	if (connection < 0)
		return false;

	if (connection >= VB->config.max_connections)
		return false;

	if (VB->connections[connection].socket == VB_INVALID_SOCKET)
		return false;

	char* mask = (char*)VB->connections[connection].active_channels;

	while (channel > 8)
	{
		channel -= 8;
		mask += 1;
	}

	return !!((*mask) & (1<<channel));
}

void vb_data_channel_activate(vb_channel_handle_t channel, size_t connection)
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	if (channel < 0)
		return;

	if (channel >= VB->next_channel)
		return;

	if (connection < 0)
		return;

	if (connection >= VB->config.max_connections)
		return;

	if (VB->connections[connection].socket == VB_INVALID_SOCKET)
		return;

	char* mask = (char*)VB->connections[connection].active_channels;

	while (channel > 8)
	{
		channel -= 8;
		mask += 1;
	}

	(*mask) |= (1 << channel);
}

void vb_data_channel_deactivate(vb_channel_handle_t channel, size_t connection)
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	if (channel < 0)
		return;

	if (channel >= VB->next_channel)
		return;

	if (connection < 0)
		return;

	if (connection >= VB->config.max_connections)
		return;

	if (VB->connections[connection].socket == VB_INVALID_SOCKET)
		return;

	char* mask = (char*)VB->connections[connection].active_channels;

	while (channel > 8)
	{
		channel -= 8;
		mask += 1;
	}

	(*mask) &= ~(1 << channel);
}

int vb_data_add_channel(const char* name, vb_data_type_t type, /*out*/ vb_channel_handle_t* handle)
{
	if (!VB)
		return 0;

	if (!name)
		return 0;

	if (!name[0])
		return 0;

	if (!handle)
		return 0;

	if (VB->next_channel >= VB->config.num_data_channels)
		return 0;

	if (VB->server_active)
		return 0;

	*handle = (vb_channel_handle_t)VB->next_channel;

	VB->channels[VB->next_channel].name = name;
	VB->channels[VB->next_channel].type = type;

	VB->next_channel++;

	return 1;
}

int vb_data_add_group(const char* name, /*out*/ vb_group_handle_t* handle)
{
	if (!VB)
		return 0;

	if (!name)
		return 0;

	if (!name[0])
		return 0;

	if (!handle)
		return 0;

	if (VB->next_group >= VB->config.num_data_groups)
		return 0;

	if (VB->server_active)
		return 0;

	*handle = (vb_group_handle_t)VB->next_group;

	VB->groups[VB->next_group].name = name;

	VB->next_group++;

	return 1;
}

int vb_data_add_channel_to_group(vb_group_handle_t group, vb_channel_handle_t channel)
{
	if (!VB)
		return 0;

	if (channel < 0 || channel >= VB->next_channel)
		return 0;

	if (group < 0 || group >= VB->next_group)
		return 0;

	if (VB->next_group_member >= VB->config.num_data_group_members)
		return 0;

	if (VB->server_active)
		return 0;

	VB->group_members[VB->next_group_member].group = group;
	VB->group_members[VB->next_group_member].channel = channel;

	VB->next_group_member++;

	return 1;
}

int vb_data_add_label(vb_channel_handle_t handle, int value, const char* label)
{
	if (!VB)
		return 0;

	if (!label)
		return 0;

	if (!label[0])
		return 0;

	if (handle < 0 || handle >= VB->next_channel)
		return 0;

	if (VB->next_label >= VB->config.num_data_labels)
		return 0;

	if (VB->server_active)
		return 0;

	VB->labels[VB->next_label].handle = handle;
	VB->labels[VB->next_label].name = label;
	VB->labels[VB->next_label].value = value;

	VB->next_label++;

	return 1;
}

int vb_data_get_label(vb_channel_handle_t handle, int value, const char** label)
{
	if (!VB)
		return false;

	if (handle < 0 || handle >= VB->next_channel)
		return false;

	if (!VB->server_active)
		return false;

	for (size_t i = 0; i < VB->next_label; i++)
	{
		if (VB->labels[i].handle == handle && VB->labels[i].value == value)
		{
			*label = VB->labels[i].name;
			return true;
		}
	}

	return false;
}

int vb_data_set_range(vb_channel_handle_t handle, float min, float max)
{
	if (!VB)
		return 0;

	if (handle < 0 || handle >= VB->next_channel)
		return 0;

	if (VB->server_active)
		return 0;

	VB->channels[handle].range_min = min;
	VB->channels[handle].range_max = max;

	return 1;
}

int vb_server_create()
{
	if (!VB)
		return 0;

	if (VB->server_active)
		return 0;

	VB->multicast_socket = socket(AF_INET, SOCK_DGRAM, 0);

	CCleanupSocket mc(VB->multicast_socket);

	if (!vb_socket_valid(VB->multicast_socket))
		return 0;

	int ttl = 10;
	if (setsockopt(VB->multicast_socket, IPPROTO_IP, IP_TTL, (const char*)&ttl, sizeof(ttl)) != 0)
	{
		VBPrintf("Couldn't set multicast socket TTL. Error: %d\n", vb_socket_error());
		return 0;
	}

	memset(&VB->multicast_addr, 0, sizeof(VB->multicast_addr));
	VB->multicast_addr.sin_family = AF_INET;
	VB->multicast_addr.sin_addr.s_addr = inet_addr(VB->config.multicast_group);
	VB->multicast_addr.sin_port = htons(VB->config.port);
	VB->last_multicast = 0;

	VB->tcp_socket = socket(AF_INET, SOCK_STREAM, 0);

	CCleanupSocket tc(VB->tcp_socket);

	if (!vb_socket_valid(VB->tcp_socket))
		return 0;

	{
		int on = 1;
		int off = 0;
		setsockopt(VB->tcp_socket, SOL_SOCKET, SO_REUSEADDR, (const char*) &on, sizeof(on));
		setsockopt(VB->tcp_socket, SOL_SOCKET, SO_LINGER, (const char*) &off, sizeof(off));
	}

#ifdef __APPLE__
	/* Don't generate SIGPIPE when writing to dead socket, we check all writes. */
	signal(SIGPIPE, SIG_IGN);
#endif

	if (vb_socket_set_blocking(VB->tcp_socket, 0) != 0)
		return 0;

	struct sockaddr_in tcp_addr;
	memset(&tcp_addr, 0, sizeof(tcp_addr));
	tcp_addr.sin_family = AF_INET;
	tcp_addr.sin_addr.s_addr = INADDR_ANY;
	tcp_addr.sin_port = htons(VB->config.port);

	if (bind(VB->tcp_socket, (struct sockaddr*) &tcp_addr, sizeof tcp_addr) != 0)
		return 0;

	if (listen(VB->tcp_socket, SOMAXCONN) != 0)
		return 0;

	VBPrintf("Viewback server created on %s:%d (%u).\n", inet_ntoa(tcp_addr.sin_addr), ntohs(tcp_addr.sin_port), tcp_addr.sin_addr.s_addr);
	VBPrintf("Multicasting to %s:%d.\n", inet_ntoa(VB->multicast_addr.sin_addr), ntohs(VB->multicast_addr.sin_port));

	mc.Success();
	tc.Success();

	VB->server_active = true;

	return 1;
}

void vb_server_shutdown()
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	vb_socket_close(VB->tcp_socket);
	vb_socket_close(VB->multicast_socket);

	for (size_t i = 0; i < VB->config.max_connections; i++)
		vb_socket_close(VB->connections[i].socket);

	VB->server_active = false;
}

size_t vb_write_length_prepended_message(struct Packet *_Packet, void *_buffer, size_t length, size_t(*serialize)(struct Packet *_Packet, void *_buffer, size_t length))
{
	size_t serialized_length = (*serialize)(_Packet, (void*)((size_t)_buffer + sizeof(size_t)), length);

	/* Packet_alloca() automatically adds sizeof(size_t) bytes to the length of the packet requested, specifically to make room for this. */
	size_t network_length = htonl(serialized_length);
	memcpy(_buffer, &network_length, sizeof(network_length));

	return serialized_length + sizeof(network_length);
}

bool vb_socket_send(vb_socket_t& socket, const char* message, size_t message_length)
{
	vb_socket_set_blocking(socket, 1);

	int bytes_sent = send(socket, message, message_length, 0);
	int socket_error = vb_socket_error();

	vb_socket_set_blocking(socket, 0);

	if (bytes_sent == 0)
	{
		VBPrintf("Error sending to %d, disconnected.\n", socket);
		vb_socket_close(socket);
		socket = VB_INVALID_SOCKET;
		return false;
	}

	if (bytes_sent < 0)
	{
		// Should be a blocking socket.
		VBAssert(!vb_socket_is_blocking_error(socket_error));

		VBPrintf("Error (code: %d) sending to %d, disconnected.\n", socket_error, socket);
		vb_socket_close(socket);
		socket = VB_INVALID_SOCKET;
		return false;
	}

	return true;
}

void vb_connection_setup(vb_connection_t* connection)
{
	// Clear the channel masks so all channels are inactive by default.
	memset(connection->active_channels, 0, vb_config_get_channel_mask_length(&VB->config));
}

#ifdef VIEWBACK_TIME_DOUBLE
void vb_server_update(double current_game_time)
#else
void vb_server_update(vb_uint64 current_game_time)
#endif
{
	if (!VB)
		return;

	if (!VB->server_active)
		return;

	VBAssert(current_game_time >= VB->current_time);

	// This sort of thing can happen the header is compiled with VIEWBACK_TIME_DOUBLE
	// and viewback.cpp is not.
	if (VB->current_time)
#ifdef VIEWBACK_TIME_DOUBLE
		VBAssert(current_game_time - VB->current_time < 100);
#else
		VBAssert(current_game_time - VB->current_time < 100000);
#endif

	VB->current_time = current_game_time;

	time_t current_time;
	time(&current_time);

	/* Advertise ourselves once per second. */
	if (current_time > VB->last_multicast)
	{
		const char message[] = "VB: HELLO WORLD"; /* TODO: put game info here. */
		if (sendto(VB->multicast_socket, (const char*)message, sizeof(message), 0, (struct sockaddr *)&VB->multicast_addr, sizeof(VB->multicast_addr)) < 0)
			VBPrintf("Multicast sendto failed, error %d\n", vb_socket_error());

		VB->last_multicast = current_time;
	}

	fd_set read_fds;

	FD_ZERO(&read_fds);

	size_t current_connections = 0;
	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (VB->connections[i].socket != VB_INVALID_SOCKET)
			current_connections++;
	}

	vb_socket_t max_socket = 0;

	if (current_connections < VB->config.max_connections)
	{
		FD_SET(VB->tcp_socket, &read_fds);
		max_socket = VB->tcp_socket;
	}

	for (size_t i = 0; i < VB->config.max_connections; ++i)
	{
		vb_socket_t socket = VB->connections[i].socket;
		if (VB->connections[i].socket == VB_INVALID_SOCKET)
			continue;

		FD_SET(socket, &read_fds);

		if (socket > max_socket)
			max_socket = socket;
	}

	struct timeval timeout;
	timeout.tv_sec = 0;
	timeout.tv_usec = 5;

	select((int) (max_socket + 1), &read_fds, NULL, NULL, &timeout);

	if (FD_ISSET(VB->tcp_socket, &read_fds))
	{
		/* We have an incoming connection. */

		VBPrintf("Incoming connection... ");

		char VB_ALIGN(8) client_addr[64];
		vb_socklen_t client_addr_len = sizeof(client_addr);
		vb_socket_t incoming_socket = accept(VB->tcp_socket, (struct sockaddr*) &client_addr[0], &client_addr_len);

		if (vb_socket_valid(incoming_socket))
		{
			CCleanupSocket c(incoming_socket);

			int open_socket = -1;
			for (size_t i = 0; i < VB->config.max_connections; i++)
			{
				if (VB->connections[i].socket == VB_INVALID_SOCKET)
				{
					open_socket = i;
					break;
				}
			}

			VBAssert(open_socket >= 0);

			if (open_socket >= 0)
			{
				VB->connections[open_socket].socket = incoming_socket;

				if (vb_socket_set_blocking(incoming_socket, 0) == 0)
				{
					int off = 0;
					setsockopt(incoming_socket, SOL_SOCKET, SO_LINGER, (const char*) &off, sizeof(int));

					vb_connection_setup(&VB->connections[open_socket]);

					c.Success();
				}
			}
		}

		if (vb_socket_valid(incoming_socket))
			VBPrintf("Successful. Socket: %d\n", incoming_socket);
		else
			VBPrintf("Dropped.\n");
	}

	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (!vb_socket_valid(VB->connections[i].socket))
			continue;

		if (FD_ISSET(VB->connections[i].socket, &read_fds))
		{
			char mesg[1024];

			int n = recv(VB->connections[i].socket, mesg, sizeof(mesg), 0);

			if (n == 0)
			{
				vb_socket_close(VB->connections[i].socket);
				VB->connections[i].socket = VB_INVALID_SOCKET;
				continue;
			}
			else if (n == sizeof(mesg))
			{
				/* We read the whole damn thing? Shouldn't ever happen, but ignore. */
				VBAssert(false);
				continue;
			}

			if (strcmp(mesg, "registrations") == 0)
			{
				VBPrintf("Sending registrations to %d.\n", VB->connections[i].socket);

				struct Packet packet;
				struct DataChannel* channels = (struct DataChannel*)alloca(VB->next_channel * sizeof(struct DataChannel));
				struct DataGroup* groups = (struct DataGroup*)alloca(VB->next_group * sizeof(struct DataGroup));
				struct DataLabel* labels = (struct DataLabel*)alloca(VB->next_label * sizeof(struct DataLabel));

				/* Initialize group channel membership numbers. */
				for (size_t j = 0; j < VB->next_group; j++)
					groups[j]._channels_repeated_len = 0;

				/* Count up how many there are. */
				for (size_t j = 0; j < VB->next_group_member; j++)
					groups[VB->group_members[j].group]._channels_repeated_len++;

				/* Now that we know how many there are we can allocate the memory. */
				for (size_t j = 0; j < VB->next_group; j++)
					groups[j]._channels = (unsigned long*)alloca(groups[j]._channels_repeated_len * sizeof(*groups[j]._channels));

				Packet_initialize_registrations(&packet, channels, VB->next_channel, groups, VB->next_group, labels, VB->next_label);

				size_t message_predicted_length = Packet_get_message_size(&packet);
				void* message = Packet_alloca(message_predicted_length);

				size_t message_actual_length = vb_write_length_prepended_message(&packet, message, message_predicted_length, &Packet_serialize);

				if (message_actual_length)
				{
					bool success = vb_socket_send(VB->connections[i].socket, (const char*)message, message_actual_length);

					if (!success)
						continue;
				}
			}
			else if (strncmp(mesg, "console: ", 9) == 0)
			{
				if (VB->config.command_callback)
					(*VB->config.command_callback)(&mesg[9]);
			}
			else if (strncmp(mesg, "activate: ", 10) == 0)
			{
				int channel = atoi(mesg + 10);
				vb_data_channel_activate((vb_channel_handle_t)channel, i);
			}
			else if (strncmp(mesg, "deactivate: ", 12) == 0)
			{
				int channel = atoi(mesg + 12);
				vb_data_channel_deactivate((vb_channel_handle_t)channel, i);
			}
			else if (strncmp(mesg, "group: ", 7) == 0)
			{
				int group = atoi(mesg + 7);

				for (size_t j = 0; j < VB->next_channel; j++)
					vb_data_channel_deactivate((vb_channel_handle_t)j, i);

				for (size_t j = 0; j < VB->next_group_member; j++)
				{
					if (VB->group_members[j].group != group)
						continue;

					vb_data_channel_activate(VB->group_members[j].channel, i);
				}
			}
		}
	}
}

void vb_send_to_all(vb_channel_handle_t channel, void* message, size_t message_length)
{
	for (size_t i = 0; i < VB->config.max_connections; i++)
	{
		if (VB->connections[i].socket == VB_INVALID_SOCKET)
			continue;

		if (!vb_data_is_channel_active(channel, i))
			continue;

		vb_socket_send(VB->connections[i].socket, (const char*)message, message_length);
	}
}

/*

Maintain time trick:

Data:     A A C B B B C D D A
Tossed:     x     x x     x
Maintain:   m->   m-m->   m->

The data comes in A B C or D. If this value is equal to the previous value,
this data gets tossed (marked by the x above.) Then the "maintain time"
is set (marked by the m above) indicating that the client should maintain
the previous value. Once a new value is received by the server, it is sent
to the client along with the maintain time, indicated by >.

*/

int vb_data_send_int(vb_channel_handle_t handle, int value)
{
	if (!VB)
		return 0;

	if (handle < 0)
		return 0;

	if (handle >= VB->next_channel)
		return 0;

	vb_data_channel_t& channel = VB->channels[handle];

	if (channel.type != VB_DATATYPE_INT)
		return 0;

	if (!VB->server_active)
		return 0;

	if (channel.flags & CHANNEL_FLAG_INITIALIZED)
	{
		if (value == channel.last_int)
		{
			channel.maintain_time = VB->current_time;
			return 1;
		}
	}
	else
		channel.flags |= CHANNEL_FLAG_INITIALIZED;

	channel.last_int = value;

	struct Packet packet;
	struct Data data;
	Packet_initialize_data(&packet, &data, VB_DATATYPE_INT);

	data._handle = handle;
	data._data_int = value;

#ifdef VIEWBACK_TIME_DOUBLE
	data._maintain_time_double = channel.maintain_time;
#else
	data._maintain_time_uint64 = channel.maintain_time;
#endif

	size_t message_predicted_length = Packet_get_message_size(&packet);
	void* message = Packet_alloca(message_predicted_length);

	size_t message_actual_length = vb_write_length_prepended_message(&packet, message, message_predicted_length, &Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb_send_to_all(handle, message, message_actual_length);

	channel.maintain_time = 0;

	return 1;
}

int vb_data_send_float(vb_channel_handle_t handle, float value)
{
	if (!VB)
		return 0;

	if (handle < 0)
		return 0;

	if (handle >= VB->next_channel)
		return 0;

	vb_data_channel_t& channel = VB->channels[handle];

	if (channel.type != VB_DATATYPE_FLOAT)
		return 0;

	if (!VB->server_active)
		return 0;

	if (channel.flags & CHANNEL_FLAG_INITIALIZED)
	{
		// I'm okay with using float == here
		if (value == channel.last_float)
		{
			channel.maintain_time = VB->current_time;
			return 1;
		}
	}
	else
		channel.flags |= CHANNEL_FLAG_INITIALIZED;

	channel.last_float = value;

	struct Packet packet;
	struct Data data;
	Packet_initialize_data(&packet, &data, VB_DATATYPE_FLOAT);

	data._handle = handle;
	data._data_float = value;

#ifdef VIEWBACK_TIME_DOUBLE
	data._maintain_time_double = channel.maintain_time;
#else
	data._maintain_time_uint64 = channel.maintain_time;
#endif

	size_t message_predicted_length = Packet_get_message_size(&packet);
	void* message = Packet_alloca(message_predicted_length);

	size_t message_actual_length = vb_write_length_prepended_message(&packet, message, message_predicted_length, &Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb_send_to_all(handle, message, message_actual_length);

	channel.maintain_time = 0;

	return 1;
}

int vb_data_send_vector(vb_channel_handle_t handle, float x, float y, float z)
{
	if (!VB)
		return 0;

	if (handle < 0)
		return 0;

	if (handle >= VB->next_channel)
		return 0;

	vb_data_channel_t& channel = VB->channels[handle];

	if (channel.type != VB_DATATYPE_VECTOR)
		return 0;

	if (!VB->server_active)
		return 0;

	if (channel.flags & CHANNEL_FLAG_INITIALIZED)
	{
		// I'm okay with using float == here
		if (x == channel.last_float_x && y == channel.last_float_y && z == channel.last_float_z)
		{
			channel.maintain_time = VB->current_time;
			return 1;
		}
	}
	else
		channel.flags |= CHANNEL_FLAG_INITIALIZED;

	channel.last_float_x = x;
	channel.last_float_y = y;
	channel.last_float_z = z;

	struct Packet packet;
	struct Data data;
	Packet_initialize_data(&packet, &data, VB_DATATYPE_VECTOR);

	data._handle = handle;
	data._data_float_x = x;
	data._data_float_y = y;
	data._data_float_z = z;

#ifdef VIEWBACK_TIME_DOUBLE
	data._maintain_time_double = channel.maintain_time;
#else
	data._maintain_time_uint64 = channel.maintain_time;
#endif

	size_t message_predicted_length = Packet_get_message_size(&packet);
	void* message = Packet_alloca(message_predicted_length);

	size_t message_actual_length = vb_write_length_prepended_message(&packet, message, message_predicted_length, &Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb_send_to_all(handle, message, message_actual_length);

	channel.maintain_time = 0;

	return 1;
}

int vb_data_send_int_s(const char* channel, int value)
{
	if (!channel)
		return 0;

	if (!channel[0])
		return 0;

	for (size_t i = 0; i < VB->next_channel; i++)
	{
		if (strcmp(VB->channels[i].name, channel) == 0 && VB->channels[i].type == VB_DATATYPE_INT)
			return vb_data_send_int((vb_channel_handle_t)i, value);
	}

	return 0;
}

int vb_data_send_float_s(const char* channel, float value)
{
	if (!channel)
		return 0;

	if (!channel[0])
		return 0;

	for (size_t i = 0; i < VB->next_channel; i++)
	{
		if (strcmp(VB->channels[i].name, channel) == 0 && VB->channels[i].type == VB_DATATYPE_FLOAT)
			return vb_data_send_float((vb_channel_handle_t)i, value);
	}

	return 0;
}

int vb_data_send_vector_s(const char* channel, float x, float y, float z)
{
	if (!channel)
		return 0;

	if (!channel[0])
		return 0;

	for (size_t i = 0; i < VB->next_channel; i++)
	{
		if (strcmp(VB->channels[i].name, channel) == 0 && VB->channels[i].type == VB_DATATYPE_VECTOR)
			return vb_data_send_vector((vb_channel_handle_t)i, x, y, z);
	}

	return 0;
}

int vb_console_append(const char* text)
{
	if (!VB)
		return 0;

	if (!VB->server_active)
		return 0;

	struct Packet packet;
	Packet_initialize(&packet);

	packet._console_output = text;
	packet._console_output_len = strlen(text);

	size_t message_predicted_length = Packet_get_message_size(&packet);
	void* message = Packet_alloca(message_predicted_length);

	size_t message_actual_length = vb_write_length_prepended_message(&packet, message, message_predicted_length, &Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb_send_to_all(VB_CHANNEL_NONE, message, message_actual_length);

	return 1;
}

int vb_status_set(const char* text)
{
	if (!VB)
		return 0;

	if (!VB->server_active)
		return 0;

	struct Packet packet;
	Packet_initialize(&packet);

	packet._status = text;
	packet._status_len = strlen(text);

	size_t message_predicted_length = Packet_get_message_size(&packet);
	void* message = Packet_alloca(message_predicted_length);

	size_t message_actual_length = vb_write_length_prepended_message(&packet, message, message_predicted_length, &Packet_serialize);

	if (!message_actual_length)
		return 0;

	vb_send_to_all(VB_CHANNEL_NONE, message, message_actual_length);

	return 1;
}

void vb_debug_printf(const char* format, ...)
{
	if (!VB->config.debug_output_callback)
		return;

	char buf[1024];
	va_list ap;
	va_start(ap, format);
#ifdef _MSC_VER
	vsnprintf_s(buf, sizeof(buf), format, ap);
#else
	vsnprintf(buf, sizeof(buf), format, ap);
#endif
	va_end(ap);

	VB->config.debug_output_callback(buf);
}











/* ====================================== PROTOBUF GENERATOR ====================================== */
/* This code unscrupulously stolen from http://code.google.com/p/protobuf-embedded-c/ 
which is under the http://www.apache.org/licenses/LICENSE-2.0 Apache license.
In accordance with this license I must inford you that I have modified it for my purposes. */

int write_raw_byte(char value, void *_buffer, int offset)
{
	*((char *)_buffer + offset) = value;
	return ++offset;
}

int write_raw_bytes(const char *bytes, int bytes_size, void *_buffer, int offset)
{
	int i; 
	for (i = 0; i < bytes_size; ++ i)
	{
		offset = write_raw_byte((char)*(bytes + i), _buffer, offset);
	}

	return offset;
}

int write_raw_varint32(unsigned long value, void *_buffer, int offset)
{
	while (1)
	{
		if ((value & ~0x7F) == 0)
		{
			offset = write_raw_byte((char)value, _buffer, offset);
			return offset;
		}
		else
		{
			offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
			value = value >> 7;
		}
	}
	return offset;
}

int write_raw_varint64(unsigned long long value, void *_buffer, int offset)
{
	while (1)
	{
		if ((value & ~0x7F) == 0)
		{
			offset = write_raw_byte((char)value, _buffer, offset);
			return offset;
		}
		else
		{
			offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
			value = value >> 7;
		}
	}
	return offset;
}

#define PB_WIRE_TYPE_VARINT           0
#define PB_WIRE_TYPE_64BIT            1
#define PB_WIRE_TYPE_LENGTH_DELIMITED 2
#define PB_WIRE_TYPE_32BIT            5

int write_wire_format(unsigned long field_number, unsigned char wire_type, void *_buffer, int offset)
{
	return write_raw_varint32((field_number << 3) + wire_type, _buffer, offset);
}

int write_raw_little_endian32(unsigned long value, void *_buffer, int offset)
{
	offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >>  8) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);

	return offset;
}

int write_raw_little_endian64(unsigned long long value, void *_buffer, int offset)
{
	offset = write_raw_byte((char)((value)& 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 8) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 16) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 24) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 32) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 40) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 48) & 0xFF), _buffer, offset);
	offset = write_raw_byte((char)((value >> 56) & 0xFF), _buffer, offset);

	return offset;
}

int vb_data_type_t_write_with_tag(vb_data_type_t *_vb_data_type_t, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = write_wire_format(tag, PB_WIRE_TYPE_VARINT, _buffer, offset);
	/* Write content.*/
	offset = write_raw_varint32(*_vb_data_type_t, _buffer, offset);

	return offset;
}

int Data_write(struct Data *_Data, void *_buffer, int offset)
{
	/* Always write the handle */
	offset = write_wire_format(1, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = write_raw_varint32(_Data->_handle, _buffer, offset);

	if (_Data->_type == VB_DATATYPE_INT)
	{
		offset = write_wire_format(3, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = write_raw_varint32(_Data->_data_int, _buffer, offset);
	}

	if (_Data->_type == VB_DATATYPE_FLOAT)
	{
		unsigned long *data_float_ptr = (unsigned long *)&_Data->_data_float;

		offset = write_wire_format(4, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = write_raw_little_endian32(*data_float_ptr, _buffer, offset);
	}

	if (_Data->_type == VB_DATATYPE_VECTOR)
	{
		unsigned long *data_float_x_ptr = (unsigned long *)&_Data->_data_float_x;
		unsigned long *data_float_y_ptr = (unsigned long *)&_Data->_data_float_y;
		unsigned long *data_float_z_ptr = (unsigned long *)&_Data->_data_float_z;

		offset = write_wire_format(5, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = write_raw_little_endian32(*data_float_x_ptr, _buffer, offset);

		offset = write_wire_format(6, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = write_raw_little_endian32(*data_float_y_ptr, _buffer, offset);

		offset = write_wire_format(7, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = write_raw_little_endian32(*data_float_z_ptr, _buffer, offset);
	}

#ifdef VIEWBACK_TIME_DOUBLE
	unsigned long long *data_time = (unsigned long long *)&_Data->_time_double;
	offset = write_wire_format(8, PB_WIRE_TYPE_64BIT, _buffer, offset);
	offset = write_raw_little_endian64(*data_time, _buffer, offset);
#else
	offset = write_wire_format(9, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = write_raw_varint64(_Data->_time_uint64, _buffer, offset);
#endif

#ifdef VIEWBACK_TIME_DOUBLE
	if (_Data->_maintain_time_double)
	{
		unsigned long long *data_maintain_time = (unsigned long long *)&_Data->_maintain_time_double;
		offset = write_wire_format(10, PB_WIRE_TYPE_64BIT, _buffer, offset);
		offset = write_raw_little_endian64(*data_maintain_time, _buffer, offset);
	}
#else
	if (_Data->_maintain_time_uint64)
	{
		offset = write_wire_format(11, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = write_raw_varint64(_Data->_maintain_time_uint64, _buffer, offset);
	}
#endif

	return offset;
}

int Data_write_delimited_to(struct Data *_Data, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = Data_write(_Data, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	write_raw_varint32((unsigned long) size, _buffer, offset);

	return new_offset + shift;
}

int Data_write_with_tag(struct Data *_Data, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = Data_write_delimited_to(_Data, _buffer, offset);

	return offset;
}

int DataChannel_write(struct DataChannel *_DataChannel, void *_buffer, int offset)
{
	VBAssert(_DataChannel->_field_name_len);
	VBAssert(_DataChannel->_field_name);
	VBAssert(_DataChannel->_field_name[0]);
	VBAssert(_DataChannel->_type);

	if (_DataChannel->_field_name_len != 1 || _DataChannel->_field_name[0] != '0')
	{
		offset = write_wire_format(1, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = write_raw_varint32(_DataChannel->_field_name_len, _buffer, offset);
		offset = write_raw_bytes(_DataChannel->_field_name, _DataChannel->_field_name_len, _buffer, offset);
	}

	offset = vb_data_type_t_write_with_tag(&_DataChannel->_type, _buffer, offset, 2);

	offset = write_wire_format(3, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = write_raw_varint32(_DataChannel->_handle, _buffer, offset);

	if (_DataChannel->_min != 0 || _DataChannel->_max != 0)
	{
		unsigned long *min_ptr = (unsigned long *)&_DataChannel->_min;
		unsigned long *max_ptr = (unsigned long *)&_DataChannel->_max;

		offset = write_wire_format(4, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = write_raw_little_endian32(*min_ptr, _buffer, offset);

		offset = write_wire_format(5, PB_WIRE_TYPE_32BIT, _buffer, offset);
		offset = write_raw_little_endian32(*max_ptr, _buffer, offset);
	}

	return offset;
}

int DataGroup_write(struct DataGroup *_DataGroup, void *_buffer, int offset)
{
	VBAssert(_DataGroup->_name_len);
	VBAssert(_DataGroup->_name);
	VBAssert(_DataGroup->_name[0]);

	if (_DataGroup->_name_len != 1 || _DataGroup->_name[0] != '0')
	{
		offset = write_wire_format(1, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = write_raw_varint32(_DataGroup->_name_len, _buffer, offset);
		offset = write_raw_bytes(_DataGroup->_name, _DataGroup->_name_len, _buffer, offset);
	}

	for (int channels_cnt = 0; channels_cnt < _DataGroup->_channels_repeated_len; ++channels_cnt)
	{
		offset = write_wire_format(2, PB_WIRE_TYPE_VARINT, _buffer, offset);
		offset = write_raw_varint32(_DataGroup->_channels[channels_cnt], _buffer, offset);
	}

	return offset;
}

int DataLabel_write(struct DataLabel *_DataLabel, void *_buffer, int offset)
{
	VBAssert(_DataLabel->_field_name_len);
	VBAssert(_DataLabel->_field_name);
	VBAssert(_DataLabel->_field_name[0]);

	offset = write_wire_format(1, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = write_raw_varint32(_DataLabel->_handle, _buffer, offset);

	offset = write_wire_format(2, PB_WIRE_TYPE_VARINT, _buffer, offset);
	offset = write_raw_varint32(_DataLabel->_value, _buffer, offset);

	if (_DataLabel->_field_name_len != 1 || _DataLabel->_field_name[0] != '0')
	{
		offset = write_wire_format(3, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = write_raw_varint32(_DataLabel->_field_name_len, _buffer, offset);
		offset = write_raw_bytes(_DataLabel->_field_name, _DataLabel->_field_name_len, _buffer, offset);
	}

	return offset;
}

int DataChannel_write_delimited_to(struct DataChannel *_DataChannel, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = DataChannel_write(_DataChannel, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	write_raw_varint32((unsigned long) size, _buffer, offset);         

	return new_offset + shift;
}

int DataGroup_write_delimited_to(struct DataGroup *_DataGroup, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = DataGroup_write(_DataGroup, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; --i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int DataLabel_write_delimited_to(struct DataLabel *_DataLabel, void *_buffer, int offset)
{
	int i, shift, new_offset, size;

	new_offset = DataLabel_write(_DataLabel, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; --i)
		*((char *)_buffer + i + shift) = *((char *)_buffer + i);

	write_raw_varint32((unsigned long)size, _buffer, offset);

	return new_offset + shift;
}

int DataChannel_write_with_tag(struct DataChannel *_DataChannel, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = DataChannel_write_delimited_to(_DataChannel, _buffer, offset);

	return offset;
}

int DataGroup_write_with_tag(struct DataGroup *_DataGroup, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = DataGroup_write_delimited_to(_DataGroup, _buffer, offset);

	return offset;
}

int DataLabel_write_with_tag(struct DataLabel *_DataLabel, void *_buffer, int offset, int tag)
{
	/* Write tag.*/
	offset = write_wire_format(tag, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
	/* Write content.*/
	offset = DataLabel_write_delimited_to(_DataLabel, _buffer, offset);

	return offset;
}

int Packet_write(struct Packet *_Packet, void *_buffer, int offset)
{
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if (_Packet->_data)
	{
		offset = Data_write_with_tag(_Packet->_data, _buffer, offset, 1);
	}

	for (int data_channels_cnt = 0; data_channels_cnt < _Packet->_data_channels_repeated_len; ++data_channels_cnt)
		offset = DataChannel_write_with_tag(&_Packet->_data_channels[data_channels_cnt], _buffer, offset, 2);

	for (int data_groups_cnt = 0; data_groups_cnt < _Packet->_data_groups_repeated_len; ++data_groups_cnt)
		offset = DataGroup_write_with_tag(&_Packet->_data_groups[data_groups_cnt], _buffer, offset, 3);

	for (int data_labels_cnt = 0; data_labels_cnt < _Packet->_data_labels_repeated_len; ++data_labels_cnt)
		offset = DataLabel_write_with_tag(&_Packet->_data_labels[data_labels_cnt], _buffer, offset, 4);

	if (_Packet->_console_output_len && _Packet->_console_output && _Packet->_console_output[0])
	{
		offset = write_wire_format(5, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = write_raw_varint32(_Packet->_console_output_len, _buffer, offset);
		offset = write_raw_bytes(_Packet->_console_output, _Packet->_console_output_len, _buffer, offset);
	}

	if (_Packet->_status_len && _Packet->_status && _Packet->_status[0])
	{
		offset = write_wire_format(6, PB_WIRE_TYPE_LENGTH_DELIMITED, _buffer, offset);
		offset = write_raw_varint32(_Packet->_status_len, _buffer, offset);
		offset = write_raw_bytes(_Packet->_status, _Packet->_status_len, _buffer, offset);
	}

	return offset;
}

void Packet_initialize(struct Packet* packet)
{
	memset(packet, 0, sizeof(struct Packet));
}

void Packet_initialize_data(struct Packet* packet, struct Data* data, vb_data_type_t type)
{
	memset(packet, 0, sizeof(struct Packet));

	packet->_data = data;

	memset(data, 0, sizeof(struct Data));

	data->_type = type;

#ifdef VIEWBACK_TIME_DOUBLE
	data->_time_double = VB->current_time;
#else
	data->_time_uint64 = VB->current_time;
#endif
}

void Packet_initialize_registrations(struct Packet* packet, struct DataChannel* data_channels, size_t channels, struct DataGroup* data_groups, size_t groups, struct DataLabel* data_labels, size_t labels)
{
	memset(packet, 0, sizeof(struct Packet));

	packet->_data_channels = data_channels;
	packet->_data_channels_repeated_len = channels;

	packet->_data_groups = data_groups;
	packet->_data_groups_repeated_len = groups;

	packet->_data_labels = data_labels;
	packet->_data_labels_repeated_len = labels;

	memset(data_channels, 0, sizeof(struct DataChannel) * channels);
	/* memset(data_groups, 0, sizeof(struct DataGroup) * groups); /* Don't zero the groups or we'll lose the channels allocation that was done. */
	memset(data_labels, 0, sizeof(struct DataLabel) * labels);

	VBAssert(channels == VB->next_channel);
	for (size_t i = 0; i < channels; i++)
	{
		data_channels[i]._field_name = VB->channels[i].name;
		data_channels[i]._field_name_len = strlen(VB->channels[i].name);
		data_channels[i]._handle = i;
		data_channels[i]._type = VB->channels[i].type;
		data_channels[i]._min = VB->channels[i].range_min;
		data_channels[i]._max = VB->channels[i].range_max;
	}

	VBAssert(groups == VB->next_group);
	for (size_t i = 0; i < groups; i++)
	{
		data_groups[i]._name = VB->groups[i].name;
		data_groups[i]._name_len = strlen(VB->groups[i].name);
	}

	/* Re-initialize group channel membership numbers, we're going to use them as counters. */
	for (size_t i = 0; i < VB->next_group; i++)
		data_groups[i]._channels_repeated_len = 0;

	/* Fill in the data. */
	for (size_t i = 0; i < VB->next_group_member; i++)
	{
		auto& group_member = VB->group_members[i];
		auto& group = data_groups[group_member.group];
		group._channels[group._channels_repeated_len] = group_member.channel;
		group._channels_repeated_len++;
	}

	VBAssert(labels == VB->next_label);
	for (size_t i = 0; i < labels; i++)
	{
		data_labels[i]._field_name = VB->labels[i].name;
		data_labels[i]._field_name_len = strlen(VB->labels[i].name);
		data_labels[i]._handle = VB->labels[i].handle;
		data_labels[i]._value = VB->labels[i].value;
	}
}

size_t Packet_get_message_size(struct Packet *_Packet)
{
	size_t size = 0;

	if (_Packet->_data)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 1; /* One byte for the length of Data, which is going to be max 40 or so. */

		size += 1; /* One byte for "handle" and wire type. */
		size += 3; /* 3 bytes is enough for a varint-encoded unsigned short. */

		if (_Packet->_data->_type == VB_DATATYPE_INT)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a varint. */
		}

		if (_Packet->_data->_type == VB_DATATYPE_FLOAT)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */
		}

		if (_Packet->_data->_type == VB_DATATYPE_VECTOR)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the field number and wire type. */
			size += 4; /* 4 bytes for a float. */
		}

		size += 1; /* One byte for "time" field number and wire type */
		size += 8; /* 8 bytes for a double. */

#ifdef VIEWBACK_TIME_DOUBLE
		if (_Packet->_data->_maintain_time_double)
#else
		if (_Packet->_data->_maintain_time_uint64)
#endif
		{
			size += 1; /* One byte for "maintain_time" field number and wire type */
			size += 10; /* If it's a double it'll be 8 bits but if it's a 64 bit varint it could be as many as 10. */
		}
	}

	if (_Packet->_data_channels_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Channels. */

		for (int i = 0; i < _Packet->_data_channels_repeated_len; i++)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 1; /* One byte for the length of DataChannel, which is going to be max 50 or so. */

			size += 1; /* One byte for "type" field number and wire type. */
			size += 2; /* Two bytes in case we ever get a lot of types. */

			size += 1; /* One byte for "handle" field number and wire type. */
			size += 3; /* 3 bytes is enough for a varint-encoded unsigned short. */

			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			size += 1; /* One byte for "min" field number and wire type. */
			size += 4; /* 4 bytes for a float. */

			size += 1; /* One byte for the "max" number and wire type. */
			size += 4; /* 4 bytes for a float. */

			/* Add on the size for each string. */
			size += _Packet->_data_channels[i]._field_name_len;
		}
	}

	if (_Packet->_data_groups_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Groups. */

		for (int i = 0; i < _Packet->_data_groups_repeated_len; i++)
		{
			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			/* Add on the size for each string. */
			size += _Packet->_data_groups[i]._name_len;

			int channels = _Packet->_data_groups[i]._channels_repeated_len;
			size += 1 * channels; /* One byte for "channels" field number and wire type. */
			size += 3 * channels; /* 3 bytes is enough for a varint-encoded unsigned short. */
		}
	}

	if (_Packet->_data_labels_repeated_len)
	{
		size += 1; /* One byte for the field number and wire type. */
		size += 2; /* Two bytes for the length of Labels. */

		for (int i = 0; i < _Packet->_data_labels_repeated_len; i++)
		{
			size += 1; /* One byte for the field number and wire type. */
			size += 1; /* One byte for the length of DataLabel, which is going to be max 50 or so. */

			size += 1; /* One byte for "handle" field number and wire type. */
			size += 3; /* 3 bytes is enough for a varint-encoded unsigned short. */

			size += 1; /* One byte for "value" field number and wire type. */
			size += 8; /* Value could be anything, assume 8 byte long is possible. */

			size += 1; /* One byte for "name" field number and wire type. */
			size += 4; /* 4 bytes to support really long strings. */

			/* Add on the size for each string. */
			size += _Packet->_data_labels[i]._field_name_len;
		}
	}

	if (_Packet->_console_output_len)
	{
		size += 1; /* One byte for field number and wire type. */
		size += 4; /* 4 bytes to support really long strings. */
		size += _Packet->_console_output_len;
	}

	if (_Packet->_status_len)
	{
		size += 1; /* One byte for field number and wire type. */
		size += 4; /* 4 bytes to support really long strings. */
		size += _Packet->_status_len;
	}

	return size;
}

size_t Packet_serialize(struct Packet *_Packet, void *_buffer, size_t length)
{
	size_t end_offset = Packet_write(_Packet, _buffer, 0);

	VBAssert(end_offset < length);

	/* Uh-oh, some overwriting happened. Too late to fix it, but don't use it. */
	if (end_offset >= length)
		return 0;

	return end_offset;
}
