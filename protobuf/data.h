/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : Data.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#ifndef _Data_H
#define _Data_H

#ifdef __cplusplus
  extern "C" {
#endif

#define MAX_STRING_LENGTH 32
#define MAX_REPEATED_LENGTH 100

/*******************************************************************
 * General functions
 *******************************************************************/

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length);


/*******************************************************************
 * Enumeration: Data.proto, line 10
 *******************************************************************/
enum vb_data_type_t {
    _VB_DATATYPE_NONE = 0,
    _VB_DATATYPE_INT = 1,
    _VB_DATATYPE_FLOAT = 2,
    _VB_DATATYPE_VECTOR = 3
};



/*******************************************************************
 * Message: Data.proto, line 17
 *******************************************************************/

/* Maximum size of a serialized Data-message, useful for buffer allocation. */
#define MAX_Data_SIZE 50

/* Structure that holds a deserialized Data-message. */
struct Data {
    unsigned long _handle;
    unsigned long _data_int;
    float _data_float;
    float _data_float_x;
    float _data_float_y;
    float _data_float_z;
    double _time;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Data_write_delimited_to(struct Data *_Data, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Data_write_with_tag(struct Data *_Data, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Data_read_delimited_from(void *_buffer, struct Data *_Data, int offset);


/*******************************************************************
 * Message: Data.proto, line 27
 *******************************************************************/

/* Maximum size of a serialized DataRegistration-message, useful for buffer allocation. */
#define MAX_DataRegistration_SIZE 47

/* Structure that holds a deserialized DataRegistration-message. */
struct DataRegistration {
    int _field_name_len;
    char _field_name[MAX_STRING_LENGTH];
    enum vb_data_type_t _type;
    unsigned long _handle;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int DataRegistration_write_delimited_to(struct DataRegistration *_DataRegistration, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int DataRegistration_write_with_tag(struct DataRegistration *_DataRegistration, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int DataRegistration_read_delimited_from(void *_buffer, struct DataRegistration *_DataRegistration, int offset);


/*******************************************************************
 * Message: Data.proto, line 33
 *******************************************************************/

/* Maximum size of a serialized DataLabel-message, useful for buffer allocation. */
#define MAX_DataLabel_SIZE 51

/* Structure that holds a deserialized DataLabel-message. */
struct DataLabel {
    unsigned long _handle;
    unsigned long _value;
    int _field_name_len;
    char _field_name[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int DataLabel_write_delimited_to(struct DataLabel *_DataLabel, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int DataLabel_write_with_tag(struct DataLabel *_DataLabel, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int DataLabel_read_delimited_from(void *_buffer, struct DataLabel *_DataLabel, int offset);


/*******************************************************************
 * Message: Data.proto, line 39
 *******************************************************************/

/* Maximum size of a serialized Packet-message, useful for buffer allocation. */
#define MAX_Packet_SIZE 9887

/* Structure that holds a deserialized Packet-message. */
struct Packet {
    struct Data _data;
    int _data_registrations_repeated_len;
    struct DataRegistration _data_registrations[MAX_REPEATED_LENGTH];
    int _data_labels_repeated_len;
    struct DataLabel _data_labels[MAX_REPEATED_LENGTH];
    int _console_output_len;
    char _console_output[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Packet_write_delimited_to(struct Packet *_Packet, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Packet_write_with_tag(struct Packet *_Packet, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Packet_read_delimited_from(void *_buffer, struct Packet *_Packet, int offset);



#ifdef __cplusplus
  }
#endif

#endif

